<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>游戏开发中的设计模式(一) -- 命令模式 | tomorrow</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://TomorrowTown.github.io/favicon.ico?v=1605546132408">
<link rel="stylesheet" href="https://TomorrowTown.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="A command is a reified method call.
使用场景示例
输入处理
每个游戏都有一处代码块用来处理用户原始的输入，如：按钮点击、键盘事件、鼠标点击等。
它会记录输入并转换为游戏中的一个动作。
简单实现：
void..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://TomorrowTown.github.io">
        <img src="https://TomorrowTown.github.io/images/avatar.png?v=1605546132408" class="site-logo">
        <h1 class="site-title">tomorrow</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://TomorrowTown.github.io" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://TomorrowTown.github.io/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://TomorrowTown.github.io/archives" class="site-nav">
            文档
          </a>
        
      
        
          <a href="https://TomorrowTown.github.io/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Remember to look up at the stars and not on your feet.
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://TomorrowTown.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">游戏开发中的设计模式(一) -- 命令模式</h2>
            <div class="post-date">2020-11-16</div>
            
            <div class="post-content" v-pre>
              <p>A command is a reified method call.</p>
<h2 id="使用场景示例"><strong>使用场景示例</strong></h2>
<h3 id="输入处理"><strong>输入处理</strong></h3>
<p>每个游戏都有一处代码块用来处理用户原始的输入，如：按钮点击、键盘事件、鼠标点击等。<br>
它会记录输入并转换为游戏中的一个动作。<br>
简单实现：</p>
<pre><code class="language-C++">void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) jump();
    else if (isPressed(BUTTON_Y)) fire();
    else if (isPressed(BUTTON_A)) swapWeapon();
    else if (isPressed(BUTTON_B)) lurchInffectively();
}
</code></pre>
<p>上述代码是有效的，但是如今许多游戏允许用户自定义按钮与游戏行为之间的映射关系。<br>
所以，为了支持自定义，我们需要把对jump()、fire()等方法的直接调用转换为<strong>可更换的</strong>东西。<br>
因此我们需要使用对象来代表一个游戏动作。这就用到了命令模式。<br>
首先，定义一个基类，代表一个可触发的游戏命令：</p>
<pre><code class="language-C++">class Command
{
public:
    virtual ~Command() {}
    virtual void execute() = 0;    
};
</code></pre>
<p>然后为每一个不同的游戏动作创建一个子类：</p>
<pre><code class="language-C++">class JumpCmd : public Command
{
public:
    virtual void execute() { jump(); }
};

class FireCmd : public Command
{
    virtual void execute() { fire(); }
};

/// #TODO: add more action subclass . . .
</code></pre>
<p>在输入处理中，为每个按钮存储一个指向命令的指针：</p>
<pre><code class="language-C++">class InputHandler
{
public:
    void handleInput();

    ///  #TODO: method to bind commands . . .

private:
    Command* button_X;
    Command* button_Y;
    Command* button_A;
    Command* button_B;
};
</code></pre>
<p>现在对输入的处理便通过这些指针进行<strong>代理</strong>：</p>
<pre><code class="language-C++">void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) button_X-&gt;execute();
    else if (isPressed(BUTTON_Y) button_Y-&gt;execute();
    else if (isPressed(BUTTON_A) button_A-&gt;execute();
    else if (isPressed(BUTTON_B) button_B-&gt;execute();
}
</code></pre>
<p>之前每个输入都会直接调用一个函数，现在则增加了一个间接调用层。</p>
<h4 id="解耦角色和命令"><strong>解耦角色和命令</strong></h4>
<p>在上例中，这些命令的使用范围很窄，只能作用于玩家对象。现在，让我们放宽限制，传入任何一个我们想要控制的对象，而不是让命令自身来确定所控制的对象：</p>
<pre><code class="language-C++">class Command
{
public:
    virtual ~Command() {}
    virtual void execute(GameActor&amp; actor) = 0;
};

class JumpCmd : public Command
{
public:
    virtual void execute(GameActor&amp; actor) { actor.jump(); }
};
</code></pre>
<p>接下来修改输入处理方法，使其返回一个命令实例，以便调用具体的execute()：</p>
<pre><code class="language-C++">Command* InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) return button_X;
    if (isPressed(BUTTON_Y)) return button_Y;
    if (isPressed(BUTTON_A)) return button_A;
    if (isPressed(BUTTON_B)) return button_B;

    return NULL;
}
</code></pre>
<p>最终，对输入的处理转化为动作的映射代码如下：</p>
<pre><code class="language-C++">Command* cmd = inputHandler.handleInput();
if (cmd) { cmd-&gt;execute(actor); }
</code></pre>
<h3 id="undoredo"><strong>undo&amp;redo</strong></h3>
<p>命令模式一个重要的应用就是“撤销操作”。因为命令对象可以<strong>do</strong>一些事，那么就应该能够轻松地<strong>undo</strong>它们。这在游戏中应用广泛，比如策略游戏中的回滚操作，以及一些游戏的重播功能。<br>
与上述例子中，我们希望从被操控的角色中抽象出命令，以便角色和命令解耦；但在这个例子中，我们希望<u>将命令绑定到被移动的角色</u>上，以便能够实现角色动作的回滚。<br>
示例代码：<br>
封装移动操作：</p>
<pre><code class="language-C++">class MoveUnitCmd : public Command
{
public:
    MoveUnitCmd(Unit* unit, int x, int y) : mUnit(uint), mX(x), mY(y) {}
    virtual void execute() { mUnit-&gt;moveTo(mX, mY); }

private:
    Unit* mUnit;
    int mX;
    int mY;
};
</code></pre>
<p>之前的输入处理程序仅维护单一的命令对象，并在对应按钮被按下时调用其execute()方法。但这里，命令将更加具体，这意味着每次玩家选择一个动作，输入处理程序代码都会创建一个命令实例：</p>
<pre><code class="language-C++">Command* handleInput()
{
    Unit* unit = getSelectedUnit();

    if (isPressed(BUTTON_UP)) {
        int destY = unit-&gt;y() - 1;
        return new MoveUnitCmd(unit, unit-&gt;x(), destY);
    }

    if (isPressed(BUTTON_DOWN)) {
        int destY = unit-&gt;y() + 1;
        return new MoveUnitCmd(unit, unit-&gt;x(), destY);
    }

    /// #TODO: others moves . . .

    return NULL;
}
</code></pre>
<p>Command类新增undo方法：</p>
<pre><code class="language-C++">class Command
{
public:
    virtual ~Command() {}
    virtual void execute() = 0;
    virtual void undo() = 0;
}
</code></pre>
<p>进一步，修改上述子类，实现undo方法：</p>
<pre><code class="language-C++">class MoveUnitCmd : public Command
{
public:
    MoveUnitCmd(Unit* unit, int x, int y)
    : mUnit(unit), mX(x), mY(y),
      xBefore(0), yBefore(0),
    {}

    virtual void execute()
    {
        // remember the unit's position before the move
        xBefore = mUnit-&gt;x();
        yBefore = mUnit-&gt;y();
        mUnit-&gt;moveTo(mX, mY);
    }

    virtual undo()
    {
        mUnit-&gt;moveTo(xBefore, yBefore);
    }

private:
    Unit* mUnit;
    int mX, mY;
    int xBefore, yBefore;
}
</code></pre>
<p>更进一步，可以支持多次撤销。<br>
具体思路是：不再只保存最后一个命令，而是维护一个命令列表和一个对当前命令的一个引用。当玩家执行了一个命令，就把该命令添加到这个列表，并将当前指针指向它。<br>
当玩家选择undo时，我们撤销当前的命令并将当前指针移回去；当选择redo时，将当前指针移回去，然后从此处开始执行后续的命令。如果撤销之后选择了一个新命令，则列表中位于当前命令之后的所有命令都被舍弃掉。</p>
<blockquote>
<p>References:<br>
[1] Robert Nystrom. Game Programming Patterns[M]. 北京: 人民邮电出版社, 2016.</p>
</blockquote>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://TomorrowTown.github.io/post/golang-basics-array/">
                  <h3 class="post-title">
                    Golang Basics--Array
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
