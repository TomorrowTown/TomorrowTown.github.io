{"posts":[{"title":"Go语言并发编程模型(一) -- 开篇","content":"在早期，CPU在一个单核中顺序地执行机器指令，所以早期地编程语言是一种顺序地编程语言：所有地指令都以串行地方式执行。当单核CPU的频率达到极限时，就会出现多核处理器，相应的，编程语言也需要朝着并行的方向发展。 常用的并行编程模型有多线程模型、消息传递模型等。golang是基于消息并发实现其并发特性的，其将CSP并发编程模型内置到了语言中。与Erlang不同的是，golang的goroutine是由go这个关键字创建的共享内存。 go协程与系统线程 go协程(goroutine)是一种轻量级的线程。启动一个go协程，不仅简单如调用一个函数，而且启动的开销非常小，协程之间的调度成本也非常低。 go协程与系统线程的差别 go协程与系统线程的差别只是一个变量，但正是这个变量的区别导致了go并发编程的质的飞跃。 **系统级线程：**具有固定的栈大小(通常默认是2MB)，该栈主要用于在递归调用函数时保存参数和局部变量。固定栈大小会导致两个问题：一是对许多只需要少量栈空间的线程来说是一种巨大的浪费；二是需要大量栈空间的线程会面临栈溢出的风险。 **go协程：**goroutine以一个非常小的栈启动，栈大小不固定，可动态伸缩(最多为1GB)。因此启动成本非常小，所以可以启动成千上万个goroutine。 goroutine的调度器 goroutine采用半抢占式的协作调度，只有在当前goroutine被阻塞时才会导致调度。同时，它发生在用户模式下。调度器会根据具体函数只保存必要的寄存器，切换成本远低于系统线程。运行时有一个runtime.GOMAXPROCS变量，用于控制当前运行正常非阻塞Goroutine的系统线程数。 关于goroutine的调度器的详细说明请参阅：&lt;(https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/&gt; References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-yi-kai-pian/"},{"title":"Go语言基础(二) -- string","content":"与数组不同，字符串中的元素是不可修改的，字符串是一个只读字节数组。虽然字符串的长度一旦固定就不可修改，但长度并不是字符串类型的一部分。 由于Go的源码需要UTF8编码，所以出现在Go源码中的字符串常量通常是UTF8编码的。 golang中的字符串底层数据结构为reflect.StringHeader： type StringHeader struct { Data uintptr Len int } The string structure consisits of two pieces of information: the first is the underlying byte array pointed by the string, and the second is the length of the string in bytes. The string is actually a structure, so the assignment of the string is the copy process of the reflect.StringHeader structure, and does not involve the copy of the underlying byte array. 字符串结构包含两段信息：第一段是字符串所指向的底层字节数组；第二段是字符串的字节长度。字符串实际上是一个结构，所以字符串的赋值是 reflect.StringHeader结构的拷贝过程，修改赋值后的字符串并不会改变源字符串。 字符串&quot;Hello, World&quot; 对应的内存结构如图： 虽然字符串不是切片，但是也支持针对切片的操作： s := &quot;hello, world&quot; hello := s[:5] world := s[7:] 字符串可以转换成byte[] 和 rune[]，且可使用for range 去遍历字符串。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/go-yu-yan-ji-chu-er-zi-fu-chuan/"},{"title":"游戏开发中的设计模式(一) -- 命令模式","content":"A command is a reified method call. 使用场景示例 输入处理 每个游戏都有一处代码块用来处理用户原始的输入，如：按钮点击、键盘事件、鼠标点击等。 它会记录输入并转换为游戏中的一个动作。 简单实现： void InputHandler::handleInput() { if (isPressed(BUTTON_X)) jump(); else if (isPressed(BUTTON_Y)) fire(); else if (isPressed(BUTTON_A)) swapWeapon(); else if (isPressed(BUTTON_B)) lurchInffectively(); } 上述代码是有效的，但是如今许多游戏允许用户自定义按钮与游戏行为之间的映射关系。 所以，为了支持自定义，我们需要把对jump()、fire()等方法的直接调用转换为可更换的东西。 因此我们需要使用对象来代表一个游戏动作。这就用到了命令模式。 首先，定义一个基类，代表一个可触发的游戏命令： class Command { public: virtual ~Command() {} virtual void execute() = 0; }; 然后为每一个不同的游戏动作创建一个子类： class JumpCmd : public Command { public: virtual void execute() { jump(); } }; class FireCmd : public Command { virtual void execute() { fire(); } }; /// #TODO: add more action subclass . . . 在输入处理中，为每个按钮存储一个指向命令的指针： class InputHandler { public: void handleInput(); /// #TODO: method to bind commands . . . private: Command* button_X; Command* button_Y; Command* button_A; Command* button_B; }; 现在对输入的处理便通过这些指针进行代理： void InputHandler::handleInput() { if (isPressed(BUTTON_X)) button_X-&gt;execute(); else if (isPressed(BUTTON_Y) button_Y-&gt;execute(); else if (isPressed(BUTTON_A) button_A-&gt;execute(); else if (isPressed(BUTTON_B) button_B-&gt;execute(); } 之前每个输入都会直接调用一个函数，现在则增加了一个间接调用层。 解耦角色和命令 在上例中，这些命令的使用范围很窄，只能作用于玩家对象。现在，让我们放宽限制，传入任何一个我们想要控制的对象，而不是让命令自身来确定所控制的对象： class Command { public: virtual ~Command() {} virtual void execute(GameActor&amp; actor) = 0; }; class JumpCmd : public Command { public: virtual void execute(GameActor&amp; actor) { actor.jump(); } }; 接下来修改输入处理方法，使其返回一个命令实例，以便调用具体的execute()： Command* InputHandler::handleInput() { if (isPressed(BUTTON_X)) return button_X; if (isPressed(BUTTON_Y)) return button_Y; if (isPressed(BUTTON_A)) return button_A; if (isPressed(BUTTON_B)) return button_B; return NULL; } 最终，对输入的处理转化为动作的映射代码如下： Command* cmd = inputHandler.handleInput(); if (cmd) { cmd-&gt;execute(actor); } undo&amp;redo 命令模式一个重要的应用就是“撤销操作”。因为命令对象可以do一些事，那么就应该能够轻松地undo它们。这在游戏中应用广泛，比如策略游戏中的回滚操作，以及一些游戏的重播功能。 上述例子中，我们希望从被操控的角色中抽象出命令，以便角色和命令解耦；但在这个例子中，我们希望将命令绑定到被移动的角色上，以便能够实现角色动作的回滚。 示例代码： 封装移动操作： class MoveUnitCmd : public Command { public: MoveUnitCmd(Unit* unit, int x, int y) : mUnit(uint), mX(x), mY(y) {} virtual void execute() { mUnit-&gt;moveTo(mX, mY); } private: Unit* mUnit; int mX; int mY; }; 之前的输入处理程序仅维护单一的命令对象，并在对应按钮被按下时调用其execute()方法。但这里，命令将更加具体，这意味着每次玩家选择一个动作，输入处理程序代码都会创建一个命令实例： Command* handleInput() { Unit* unit = getSelectedUnit(); if (isPressed(BUTTON_UP)) { int destY = unit-&gt;y() - 1; return new MoveUnitCmd(unit, unit-&gt;x(), destY); } if (isPressed(BUTTON_DOWN)) { int destY = unit-&gt;y() + 1; return new MoveUnitCmd(unit, unit-&gt;x(), destY); } /// #TODO: others moves . . . return NULL; } Command类新增undo方法： class Command { public: virtual ~Command() {} virtual void execute() = 0; virtual void undo() = 0; } 进一步，修改上述子类，实现undo方法： class MoveUnitCmd : public Command { public: MoveUnitCmd(Unit* unit, int x, int y) : mUnit(unit), mX(x), mY(y), xBefore(0), yBefore(0), {} virtual void execute() { // remember the unit's position before the move xBefore = mUnit-&gt;x(); yBefore = mUnit-&gt;y(); mUnit-&gt;moveTo(mX, mY); } virtual undo() { mUnit-&gt;moveTo(xBefore, yBefore); } private: Unit* mUnit; int mX, mY; int xBefore, yBefore; } 更进一步，可以支持多次撤销。 具体思路是：不再只保存最后一个命令，而是维护一个命令列表和一个对当前命令的一个引用。当玩家执行了一个命令，就把该命令添加到这个列表，并将当前指针指向它。 当玩家选择undo时，我们撤销当前的命令并将当前指针移回去；当选择redo时，将当前指针移回去，然后从此处开始执行列表中的命令。如果撤销之后选择了一个新命令，则列表中位于当前命令之后的所有命令都被舍弃掉。 References: Game Programming Patterns ","link":"https://TomorrowTown.github.io/post/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi/"},{"title":"Go语言基础(一) -- array","content":"数组是一种固定长度的序列，可包含0个或多个元素。值得注意的是，长度也是决定数组类型的因素。数组由不同长度或不同类型的数据组成，那么这些数组就是不同的类型，是不能直接赋值的。因此在实际的golang项目中很少使用数组。对应于数组的类型是slice，slice是一种可以动态增长和收缩的序列，本章暂且不表。 var a [3]int // define an int-type array of length 3, all the elements are 0 var b = [...]int{1, 2, 3} // define an int-type array of length 3, elements are 1, 2, 3 var c = [...]int{2: 3, 1: 2} // define an int-type of length 3, elements are 0, 2, 3 var d = [...]int{1, 2, 4: 5, 6} // define an int-type of length 3, elements are 1, 2, 0, 0, 5, 6, /* 值得注意的是第三种和第四种方法去定义一个数组。 第三种方法：golang支持数组中的元素通过索引去初始化，因此初始化时不必按照索引从0开始递增的方式去初始化。数组的长度基于初始化时出现的最大索引，未显式初始化的元素仍然使用0值初始化。 第四种方法：混合了第四种和第三种初始化方法。 */ 内存结构： golang中的数组是值语义的。一个数组变量代表的是整个数组，不像C++，代表的是数组第一个元素的指针。当一个数组被赋值或是被传递，整个数组其实是被拷贝的，修改拷贝的数组并不会改变原数组的数据，因为他们并不共享底层数据结构。 如果数组很大，那么数组分配也会有很大的开销。为了避免复制数组的开销，可以传递一个指向数组的指针，但数组指针不是数组。 var a = [...]int{1, 2, 3} var b = &amp;a fmt.Println(a[0], a[1]) // Prints the first two elements of the array fmt.Println(b[0], b[1]) // Accessing array elements through array pointer is similar to arrays // Iterate through the elements of an array through array pointer. for i, v = range b { ...... } 遍历数组的常用方法 for i := range a { } for i, v := range a { } for i := 0 ; i &lt; len(a); i++ { } 需要注意的是，使用for range的方式进行遍历，其性能要比传统的**for i := 0 ; i &lt; len(a); i++ **要差很多。具体原因请查看：https://www.flysnow.org/2018/10/20/golang-for-range-slice-map.html 数组的其他用途 数组不仅可以用于数字类型，还可以是字符串数组，结构体数组，函数数组，接口数组，管道数组等等： // string array var s1 = [...]string{&quot;hello&quot;, &quot;world&quot;} // structure array var line = [...]image.point{{0, 0}, {1, 1}} // function array var decoder = [...]func(io.Reader) (image.Image, error) { png.Decode, jpeg.Decode, } // interface array var unknown = [...]interface{}{123, &quot;hello&quot;} // pipe array var chanList = [2]chan int{} 也可以定义空数组： var d = [0]int var e = [0]int{} var f = [...]int{} 长度为0的数组不占用内存空间。虽然空数组很少被使用，但它们可以用来强调某些类型的操作，以避免分配额外的内存空间，例如管道同步操作： c1 := make(chan [0]int) go func() { fmt.Println(&quot;c1&quot;) c1 &lt;- [0]int{} }() &lt;- c1 此处我们不关心管道中传输的实际数据类型，管道中的接收和发送操作仅用于消息同步。对于这个应用场景，我们使用一个空数组作为管道类型，以减少分配管道元素的开销。 当然，通常更倾向于使用无类型的匿名结构体以达到相同的目的： c2 := make(chan struct{}) go func() { fmt.Println(&quot;c2&quot;) c2 &lt;- struct{}{} // The part of 'struc{}' means type, and the '{}' represents the value of the structure }() &lt;- c2 在golang中，数组是切片和字符串的基础结构。数组的许多操作都可直接用于切片和字符串。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/golang-basics-array/"},{"title":"go服务器性能分析方法","content":"pprof 在需要监测的server源码中的main或init中引入: import _ &quot;net/http/pprof&quot; 启动http监听端口，以此作为性能分析数据展示网页。 go http.ListenAndServe(&quot;:9999&quot;, nil) 这样，默认访问地址为localhost:9999。 无论是否是http服务, 都可以引入**&quot;net/http/pprof&quot;**作为性能分析的工具。 go-torch和FlameGraph 安装go-torch和FlameGraph go get github.com/uber/go-torch cd $GOPATH/src/github.com/uber/go-torch git clone https://github.com/brendangregg/FlameGraph.git sudo cp ./FlameGraph/flamegraph.pl /usr/local/bin NOTE: go get到的项目默认会放到用户目录下的go文件夹，以此作为该项目的GOPATH。 可能遇到的问题: go get github.com/uber/go-torch时，有可能出现： unrecognized import path &quot;golang.org/x/sys/unix&quot;: https fetch: Get . . . . . . i/o timeout 此时需要: mkdir -p $GOPATH/src/golang.org.x cd $GOPATH/src/golang.org/x git clone https://github.com/golang/sys.git 即可 安装包管理工具 glide用于编译上述下载的go-torch。 go get github.com/Masterminds/glide cd $GOPATH/src/github.com/uber/go-torch glide install 可能遇到的问题: 在glide install时可能出现: 直接无视即可。 运行测试用例 ...... go-torch]$ go test ./... 可能遇到的问题: 出现一堆编译报错。但只要下列语句都没fail, 即可无视其他报错： 最后需要到GOPATH的bin目录下查看是否生成了go-torch可执行文件, 有则成功 运行go-torch获取火焰图 在成功完成了上述所有步骤后，在任意文件夹下都可运行 go-torch命令了。 例： go-torch -u http://localhost:9999 -t 30 -f perf.svg 等待30s，在运行命令的目录下就会生成一份perf.svg（默认是torch.svg）文件, 直接网页打开(实测chome/Edge可正常打开并可点击方块zoom in)该文件即可看到火焰图： 进一步寻找性能痛点 再次用相同的测试条件测试，不过现在仅需要运行： go tool pprof --seconds 60 http://localhost:9999/debug/pprof/profile 60s后会得到cpu分析文件，此时不再是火焰图。 根据之前获得的火焰图，找到不应该占用那么多CPU但是却占用了那么多的方法。 在命令行窗口(pprof)后输入list 方法名， 如果找到了具体哪一步消耗的cpu高，如果该步是另一个包的方法，也无所谓，直接list 方法名即可。 (ps: 输入exit可退出go tool pprof) 会得到该方法中具体哪一步cpu消耗的值，进而得到了该方法的性能痛点。 最后就着手优化吧:) Tips：火焰图中，纵轴从下到上代表调用顺序，横轴每个方块的长度代表占用CPU的时长百分比。 ","link":"https://TomorrowTown.github.io/post/go-fu-wu-qi-xing-neng-fen-xi-gong-ju/"}]}