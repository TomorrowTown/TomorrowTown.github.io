{"posts":[{"title":"记一次golang后台服务内存泄漏问题的排查","content":"0x00 某日我们用golang编写的后台的网关服务在使用机器人压测时出现了使用内存激增的问题(达到了6G......)，毫无疑问，内存泄露了。于是就需要利用go tool pprof进行苦逼的排查了...... 分析heap还是goroutine? 对于进程内存的分析，利用go tool pprof可以获得heap及goroutine的相关信息。那么到底是选择分析heap呢，还是goroutine呢？ 一句话结论：使用内存profiling并不能在多线程环境下排查出内存泄露的原因。 原因如下： 使用heap能获得内存分配的情况，可以具体到哪一行代码占用了过多的内存，因而可以纠正缺少对于性能考虑的编码问题。但是在多线程环境下，排除低性能编码的情况，heap得到的只是一个点，一个最终结果，一个表象。因为这一个内存占用高的代码可能被多个goroutine调用，仅用heap我们并不能找到是哪条goroutine路径造成的泄漏，找不到源头，就无法解决内存泄漏问题，因此我们将利用go tool pprof获取goroutine的profile文件去分析。俗话说的好，&quot;go服务器内存泄漏，十次有九次都是协程泄漏&quot;，所以排查的重点自然也应首先放在对于goroutine的排查上。 那么什么是goroutine泄漏？还是一句话总结：该退出的协程没退出，被阻塞了，就是协程泄漏。 分析goroutine的profile文件 后台服务开启pprof的具体方法在此省略。 1. 获取goroutine的profile文件 在启动后台服务，启动压测机器人一小段时间之后，输入： go tool pprof http://localhost:9900/debug/pprof/goroutine 获得此时的goroutine profile文件，将其作为后续比较的基准文件。输入top指令可以得到持有goroutine数量最多的10个协程从高到低的序列，如下： 接下来去喝杯茶或者带薪拉屎...... 回来之后再次输入： go tool pprof http://localhost:9900/debug/pprof/goroutine 继续top，得到： 好家伙，我他妈直接好家伙，才一泡屎的功夫，网关的协程数量就多了快300个(前提是压测机器人仅启动了十个，并且每个机器人也只发少量的rpc请求)，协程泄漏无疑了。 2. 比较两个时间点的goroutine的profile文件 在获得以上两个goroutine的profile文件的基础上，输入： go tool pprof -base 基准profile文件名 第二个较新的profile文件名 得到： 再输入traces得到第二个profile比第一个profile多出来的协程调用栈： 这里只有一个调用栈，而多出来的280个协程也正好在这个调用栈中。 在这个调用栈里面runtime.gopark这样的系统调度方法不用管，我们找自己项目里的方法，sync.(*Cond).Wait是我们项目的代码，所以输入list Wait(list支持模糊查询)命令，进去该方法内部看看： 找到项目代码里的部分，我们可以看到这280个协程阻塞在了waitForMsgs里的**s.pCond.Wait()**里了，这属于我们项目使用的mq代码。 阻塞大量协程的地方找到了，接下来就是进入到mq及项目的源码去具体分析为什么会阻塞在这里了。 nats reply subscribe接收过程 上面我们定位到了是waitForMsgs()里的s.pCond.Wait()阻塞了协程。这属于我们项目使用的开源消息中间件NATS中的代码。 waitForMsgs()中的注释如下： 由此可知该方法是用于传递消息给我们的异步sub的。 继续看waitForMsgs()的源码，如下(由于这个函数实在太多行了，所以只看最关键的for循环~)： 由以上代码可知s.pCond.Wait()是在等待其他服务向我们的sub去pub消息的，如果一直没有消息pub过来，就会一直在这里Wait，break这个for循环的条件有两个，一个是waitForMsgs()的参数Subscription的closed变量为true，另一个是达到了消息传递上限。 从源码中我并没有发现对于sub的等待超时机制，所以这个for必定不会因为超时(长时间收不到pub的消息)而将closed置为true，从而将for循环break，其实对于pub/sub模型下的mq，不做超时机制这也可以理解的；同理，如果长时间收不到对应的sub，那么for循环也不会因为达到了消息传递上限而break。由此可知，如果一个错误的sub被加载到nats-client，则会导致这个for循环长期阻塞在s.pCond.Wait()。 从waitForMsgs的Usage可以看到，它是被subscribeLocked()方法调用的： 由上图可知，每个subscribe()的调用都会go一个**waitForMsgs()**协程用于回调我们注册的方法，**subscribeLocked()又是被subscribe()**调用的，**subscribe()又被我们自己写的gateserver调用。 这样就能解释为什么gateserver的内存会泄露了，以及为什么会在s.pCond.Wait()**处阻塞大量协程了， 根本原因是NATS在nats-client sub了之后会在一个无法满足退出条件的for循环中Wait其对应的pub，且由于pub/sub模型的需要，并没有一个超时机制去清除长时间没被pub的sub。既然NATS是这么设计的，而且是合理的设计，那么出问题的只能是我们自己了...... : ( 所以导致goroutine泄漏的原因就是我们进行了错误的sub。怎么个错误法，可能的原因有两个： 我们sub了一个没有任何服务去处理的topic； 由于NATS是根据key去查找sub的，所以有可能是我们在添加KV pair时部分key是重复的，导致NATS 在pub消息时总是只能传递到所有重复key的sub的其中一个sub，进而导致其他重复key的sub始终没有收到pub的消息，从而导致它们被阻塞，且随着时间的推移，sub的次数越来越多，阻塞的goroutine也越来越多...... 压测机器人是定时发送一批sub的，假如一次分别sub的是A，B，C三个主题，而在gateserver中我们维护的sub map在add时没处理好，使得B和C拥有了相同的key，那么在B和C之中永远有一个永远收不到pub的消息，而压测机器人又在不停地sub A、B、C...... 对于第一个可能，其实是不可能的，因为对于pub/sub模型，我们针对的是“服务(Service)”这个粒度的发布和推送，而不是“方法(Method)”这个粒度的发布和推送，所以不可能是“方法”不对导致的收不到pub消息，所以没必要再画蛇添足增加对于“方法”的鉴权了(我最初就画蛇添足了，结果导致许多服务都不能用了......)。而在我们的gateserver中已经有了对于“服务”sub的鉴权了，所以在gateserver中不存在客户端能够sub一个不存在的“服务”的情况。 那么就只剩下上述第二种情况了......经查，果然是...... 每次往gateserver维护的sub map添加KV时，把原来会重复的key换成唯一key就好了...... 真傻逼的错误啊...... ","link":"https://TomorrowTown.github.io/post/golang-service-memory-leak-solve/"},{"title":"Go语言并发编程模型(九) -- context","content":"0x00 在Go1.7发布时，标准库增加了一个context包，用来简化对于处理单个请求的多个goroutine之间与请求域的数据、超时和退出等操作。 context包的应用 1. 线程安全退出和超时控制 // when the concurrent body timeout or 'main' actively stops the worker goroutine, each worker can safely exit func worker(ctx context.Context, wg *sync.WaitGroup) error { defer wg.Done() for { select { case &lt;- ctx.Done(): // exit return ctx.Err() default: fmt.Println(&quot;doing work...&quot;) } } } func main() { ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second * 10) wg := &amp;sync.WaitGroup{} for i := 0; i &lt; 10; i++ { wg.Add(1) go func() { err := worker(ctx, wg) fmt.Println(&quot;err = &quot;, err) }() } time.Sleep(time.Second) cancelFunc() wg.Wait() } 2. 防止后台goroutine内存泄漏 虽然go语言自带垃圾回收，一般不会发生内存泄漏，但当main函数不再使用channel时，后台goroutine有泄漏风险。使用context包可以避免这样的情况发生(不需要使用sync.WaitGroup了)。例： func worker(ctx context.Context) error { for { select { case &lt;- ctx.Done(): // exit return ctx.Err() default: fmt.Println(&quot;doing work...&quot;) } } } func main() { ctx, cancelFunc : = context.WithCancel(context.Background()) wg := &amp;sync.WaitGroup{} for i := 0; i &lt; 10; i++ { go func() { err := worker(ctx) }() } /* * when the main function completes its work, it will calls cancelFunc() first, * to notify the background Goroutine to exit, * thus avoiding the leakage of Goroutine. */ cancelFunc() } References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-9-golang-basics-context/"},{"title":"Go语言并发编程模型(八) -- 并发的安全退出","content":"0x00 当select有许多分支时，会随机选择一个可用的channel分支，若没有可用channel分支，则default分支将会被选择，否则会一直保持阻塞状态。 select语句的应用 1. 超时判断 // choose one of the two, without default, either perform &quot;&lt;- in&quot; or timeout(channel is still empty after one second) select { case v := &lt;- in: // do something... case &lt;- time.After(time.Second): // timeout, return return } 2. 非阻塞channel的发送和接收操作 select { case v := &lt;- in: // do something default: // there is no data in channel } 3. 阻止main函数退出 func main() { // do something select {} // keep blocking here } 4.生成随机数序列 当有多个channel可用时， select会随机选择一个可用的channel。基于此特性，我们可以实现一个随机数序列生成程序： func main() { ch := make(chan int) go func() { for { select { case ch &lt;- 0: case ch &lt;- 1: } } }() for v := range ch { // random output 0 and 1 fmt.Println(v) } } 5.协程退出控制 (1) 关闭一个goroutine func worker(cancel chan bool) { for { select { case &lt;- cancel: // exit fmt.Println(&quot;stop work...&quot;) return default: // do something... fmt.Println(&quot;doing some work...&quot;) } } } func main() { cancel := make(chan bool) go worker(cancel) time.Sleep(time.Second) cancel &lt;- true // notify goroutine quit } (2) 关闭多个goroutine 使用**close()**方法关闭channel，使其达到广播的效果，select的所有接收channel分支都会在channel关闭时收到0值。 func worker(cancel chan bool) { for { select { case v := &lt;- cancel: // exit fmt.Println(&quot;stop work... v = &quot;, v) return default: fmt.Println(&quot;doing work...&quot;) } } } func main() { cancel := make(chan bool) go worker(cancel) time.Sleep(time.Second) close(cancel) } NOTE: 由于goroutine在收到退出指令进行退出时会执行一定的清理工作，但是上述程序并不能够保证清理一定能够完成，所以为了保证程序的健壮性，我们需要使用sync.WaitGroup，以求main线程能够等待各个goroutine退出完成。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-09-golang-basics-concurrent-exit-safely/"},{"title":"Go语言并发编程模型(七) -- 控制并发数","content":"控制并发数的意义 适当地控制并发数，能够为其他程序提供可供使用的CPU资源，也可以节省能耗。 对于细粒度的并发程序而言，CSP模型中的消息传递机制的开销是非常大的(多线程并发模型不可避免地会面对线程启动的开销)。 使用有缓冲channel实现groutine的并发数控制 一个简单的示例： package main import ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot; ) var ch chan bool func worker() { fmt.Println(&quot;test&quot;) &lt;- ch } func main() { wg := &amp;sync.WaitGroup{} ch = make(chan bool, 10) for i := 0; i &lt; 1000; i++ { wg.Add(1) ch &lt;- true go worker() wg.Done() } fmt.Println(&quot;runtime goroutine num = &quot;, runtime.NumGoroutine()) wg.Wait() } 这样，同时运行的goroutine就控制在了10个。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-09-golang-basics-control-the-number-of-concurrent/"},{"title":"Go语言并发编程模型(六) -- 发布订阅模型","content":"0x00 相比于生产者消费者模型而言，消息的生产者在发布订阅模型中充当了消息的发布者(publisher)，消息的消费者充当了消息的订阅者(subscriber)。 在传统的生产者消费者模型中，消息被发送到一个队列中，而在发布订阅模型中，消息被发布给一个主题(topic)。 在发布订阅模型中，每一个消息都被传递给多个订阅者。发布者通常不知道也不关心哪个订阅者收到了主题消息。发布者和订阅者可以在运行时动态地添加，是一种松散的耦合关系，这使得系统地复杂性会随着时间的推移而增长。 一个支持多主题的pub-sub库的简易实现 package main import ( &quot;fmt&quot; &quot;strings&quot; &quot;sync&quot; &quot;time&quot; ) type ( // subscriber is a channel subscriber chan interface{} topicFunc func(v interface{}) bool ) // the publisher object type Publisher struct { m sync.RWMutex buffer int // the cache size of subscription queue timeout time.Duration // publish timeout subscribers map[subscriber]topicFunc // subscriber information } func NewPublisher(timeout time.Duration, buffer int) *Publisher { return &amp;Publisher { buffer: buffer, timeout: timeout, subscribers: make(map[subscriber]topicFunc), } } // add a new subscriber, subscribes all topic func (p *Publisher) Subscribe() chan interface{} { return p.SubscribeTopic(nil) } // add a new subscriber, subscribes the topic filtrated by filter func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} { ch := make(chan interface{}, p.buffer) p.m.Lock() p.subscribers[ch] = topic p.m.Unlock() return ch } func (p *Publisher) Exit(sub chan interface{}) { p.m.Lock() defer p.m.Unlock() delete(p.subscribers, sub) close(sub) } // publish a topic func (p *Publisher) Publish(v interface{}) { p.m.RLock() defer p.m.RUnlock() var wg sync.WaitGroup for sub, topic := range p.subscribers { wg.Add(1) go p.SendTopic(sub, topic, v, &amp;wg) } // wait for all goroutines excute finish wg.Wait() } // close publisher object, at the same time, close all the channel of subscribers func (p *Publisher) Close() { p.m.Lock() defer p.m.Unlock() for sub := range p.subscribers { delete(p.subscribers, sub) close(sub) } } // send topic, can tolerate a certain timeout func (p *Publisher) SendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) { defer wg.Done() if topic != nil &amp;&amp; !topic(v) { return } select { case sub &lt;- v: // ...... case &lt;- time.After(p.timeout): // ...... } } // test code ... func main() { p := NewPublisher(time.Millisecond * 100, 10) defer p.Close() all := p.Subscribe() gTopic := p.SubscribeTopic(func(v interface{}) bool { if s, ok := v.(string); ok { return strings.Contains(s, &quot;golang&quot;) } return false }) // pub p.Publish(&quot;hello world!&quot;) p.Publish(&quot;hello golang!&quot;) // sub go func() { for msg := range all { fmt.Println(&quot;all: &quot;, msg) } }() go func() { for msg := range gTopic { fmt.Println(&quot;golang: &quot;, msg) } }() // exit after a certain time time.Sleep(time.Second * 3) } References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-08-golang-basics-publish-and-subscribe-model/"},{"title":"Go语言并发编程模型(五) -- 生产者消费者模型","content":"talk is cheap, show you the code: // producer: generate a sequence of multiples of factor func Producer(factor int, out chan &lt;- int) { for i := 0; ; i++ { out &lt;- i * factor } } // consumer func Consumer(in &lt;- chan int) { for v := range in { fmt.Println(v) } } func main() { ch := make(chan int, 64) // result queue // the producers below are concurrency, therefore, the order of the result sequence output by the consumer is uncertain go Producer(3, ch) // generate a sequence of multiples of 3, and put them into the ch go Producer(5, ch) // generate a sequence of multiples of 5, and put them into the ch go Consumer(ch) // consume the generated sequence // exit after a certain time, let producers and consumers work for a certain time // time.Sleep(time.Second * 5) /* * but the above sleep mode cannot guarantee stable output, * so we can let the main function save the blocked state without exiting * and only exit the program when the user enters &quot;Ctrl C&quot; */ sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM) fmt.Println(&quot;quit (%v)\\n&quot;, &lt;- sig) } References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-07-golang-basics-producer-and-consumer-model/"},{"title":"Go语言并发编程模型(四) -- 基于管道的通信","content":"0x00 依靠channel通信是不同goroutine之间同步的主要方法。 无缓冲channel 对于无缓冲channel而言，每一个发送操作(chan &lt;- x)都对应一个接收操作(&lt;- chan)，反之亦然。channel的发送和接收操作通常出现在不同的goroutine之间，如果放到同一个goroutine，则很容易出现死锁问题。 使用示例： var done = make(chan bool) // define an unbuffered channel, its len and cap always equal to 0 var msg string func aGoroutine() { msg = &quot;hello world&quot; done &lt;- x // sending operation, send a synchronization signal to channel // or use close(done) to replace done &lt;- false } func main() { go aGoroutine() &lt;- done // receiving operation, receive the corresponding synchronization signal fmt.println(msg) } 有缓冲channel 通过有缓冲channel的buffer大小，我们可以控制并发执行的goroutine的最大数量。例： var limit = make(chan int, 3) // the channel with cache, length can be 0, 1, 2 or 3, capacity equals to 3 func main() { for _, w := range workerThread { go func() { limit &lt;- 1 w() &lt;- limit }() select{} // empty pipeline selcetion statement, means that only the channel be nil, the main thread can excute return } } 上述程序允许的最大并发数为3。 Summary： 无缓冲channel：如果线程A向channel进行写操作，线程B尚未对该channel进行读操作，那么A线程将会被阻塞在写操作语句。相应的，如果线程A对一个线程进行读操作，线程B尚未对channel进行写操作，那么A线程将会阻塞在读操作语句。 有缓冲channel：只有当该channel的len==cap时，即该channel满了时，向该channel再进行写操作的化，写操作语句就会被阻塞。如果该channel中无数据(即len=0)，那么读该channel的语句将会被阻塞。 无缓冲channel：实现线程间同步。 有缓冲channel：线程间是异步的。 注意：如果对channel的读和写操作在同一个线程中进行，那么很容易造成读写互相等待，即死锁。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-04-golang-basics-channel-based-communication/"},{"title":"Go语言并发编程模型(三) -- 顺序一致性内存模型","content":"0x00 原子操作能够为线程之间的数据同步提供部分保证的前提是顺序一致性内存模型。 线程间同步的本质就是为并发的事件进行排序。 以下为一个顺序一致性内存模型： var a string var done bool func set() { a = &quot;hello world&quot; done = true } func main() { go set() for !done {} fmt.Println(a) } 在Go语言中，在同一个goroutine内的内存顺序模型能够得到保证(在本例中即：go set()中的a赋值语句一定先于done赋值语句执行)。但是在不同的goroutine中，内存模型的顺序就不能单纯地通过书写顺序去保证了。假如在main线程书写一个done赋值语句，那么就无法保证go set()协程的done赋值语句和main线程的done赋值语句谁先执行了，那么print出来的a就可能为空。 这是因为在Go中，为了使并行最大化，go的编译器和处理器会对语句进行重排，同时CPU也可能会对指令集进行重排。更糟糕的是，main线程可能无法察觉到set协程中的变量变化(可能始终在寄存器内)，进而导致main线程死循环。如果并发程序不能确定事件发生的顺序，那么输出的结果也是不确定的，如以下这个程序： func main() { go fmt.Println(&quot;hello world&quot;) } 由于goroutine和return事件是并发的，这两个事件谁都可能先发生，最终是否能打印出hello world也是无法确定的。 使用同步原语进行同步 func main() { done := make(chan int) go func() { fmt.Println(&quot;111&quot;) done &lt;- 1 // 同步语句 1 }() &lt;- done // 同步语句2 fmt.Println(&quot;222&quot;) } done &lt;- 1：向channel传值；&lt;- done：从channel取值。 向channel传值取值先写谁都无所谓，因为传了没人取，和想取没人传，都会使channel阻塞， 因此同步语句2能够顺利执行(不阻塞)，就意味着同步语句1肯定执行了，又因为在一个goroutine中总能保证顺序一致性内存，因此在语句1执行之前，&quot;111&quot;肯定打印了，因此总能保证先打印&quot;111&quot;，再打印&quot;222&quot;。 使用互斥量实现同步 func main() { var mu sync.Mutex mu.Lock() go func() { fmt.Println(&quot;hello world&quot;) mu.Unlock() }() mu.Lock() } 一个goroutine内的语句能够保证顺序一致性内存，所以打印语句必发生在Unlock()之前；在main线程中，先执行了第一个Lock()，那么通过sync.Mutex内部的保证，第二个Lock()必发生在goroutine中的Unlock()之后。因此能够保证该程序正常输出hello world。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-03-golang-basics-sequential-consistency-memory-model/"},{"title":"Go语言并发编程模型(二) -- 原子操作","content":"使用互斥锁实现原子操作 通常，原子操作由“互斥”访问保证，通常由特殊的CPU指令保护。当然，如果只是想模拟粗粒度的原子操作，我们可以使用sync.Mutex来做到这一点。 package main import ( &quot;sync&quot; &quot;fmt&quot; ) var total struct { sync.Mutex value int } func worker(wg *sync.WaitGroup) { defer wg.Done() for i := 0; i &lt; 100; i++ { total.Lock() total.value += 1 total.Unlock() } } func main() { var wg sync.WaitGroup wg.Add(2) go worker(&amp;wg) go worker(&amp;wg) wg.Wait() fmt.Println(total.value) // 10100 } 使用sync/atomic实现原子操作 如上，使用互斥锁去保护数字共享资源既麻烦又低效。标准库中的sync/atomic包对此提供了丰富的支持。利用此包重新实现上面的例子： package main import ( &quot;sync&quot; &quot;sync/atomic&quot; &quot;fmt&quot; ) var total uint64 func worker(wg *sync.WaitGroup) { defer wg.Done() for i := 0; i &lt;= 100; i++ { atomic.AddUnit64(&amp;total, i) } } func main() { var wg sync.WaitGroup wg.Add(2) go worker(&amp;wg) go worker(&amp;wg) wg.Wait() fmt.Println(total.value) // 10100 } 利用原子操作和互斥锁实现单例 原子操作和互斥锁可以实现非常高效的单例模式。互斥锁的开销比普通整数的原子读写要高得多。 在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态降低互斥锁的使用次数来提高性能。 type singleton struct {} var ( instance *singleton initialized uint32 mu sync.Mutex ) func GetInst() *singleton { if atomic.LoadUint32(&amp;initialized) == 1 { return instance } mu.Lock() defer mu.Unlock() if instance == nil { defer atomic.StoreUint32(&amp;initialized, 1) instance = &amp;singleton {} } return instance } 将上例中的公共部分提取出来就是标准库中的 sync.Once包。sync.Once源码如下所示： type Once struct { m mutex done uint32 } func (o *Once) Do(f func()) { if atomic.LoadUint32(&amp;o.Done) == 1 { return } o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(&amp;o.done, 1) f() } } 现在，基于sync.Once重新实现单例模式： var ( instance *singleton once sync.Once ) func GetInst() *singleton { once.Do(func() { instance = &amp;singleton{} }) return instance } Load &amp; Store atomic.Value对象提供了Load和Store两种方法，用于加载和保存数据。其返回值和参数均为**interface{}**类型，所以这两种方法可以用于自定义的任何复杂结构。 /* This is a simplified producer-consumer model: back-end thread generate the latest configuration; multiple worker threads in the front-end get the latest configuration. All threads share configuration resources. */ // save the current configuration var conf atomic.Value // initialize the configuration conf.Store(loadConfig()) // start a backend thread, load the updated configuration go func() { for { time.Sleep(time.Second) conf.Store(loadConfig()) } } // the worker threads used to process requests, always use the latest configuration for i := 0; i &lt; 10; i++ { go func() { for r := range requests() { c := conf.Load() } }() } References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-02-golang-basics-atomic-operation/"},{"title":"Go语言并发编程模型(一) -- 开篇","content":"0x00 首先看一下并发与并行的区别： 并发：注意力更多地集中于设计层面，并发程序能够被顺序执行； 并行：注意力更多地集中于运行层面，并发程序一般是大量简单重复的运算。 在早期，CPU在一个单核中顺序地执行机器指令，所以早期地编程语言是一种顺序地编程语言：所有地指令都以串行地方式执行。当单核CPU的频率达到极限时，就会出现多核处理器，相应的，编程语言也需要朝着并行的方向发展。 在并发编程中，对资源的精确访问需要精确的控制。在大多数语言中，这个困难的问题是通过锁和其他同步解决方案来解决的。但在golang中有另一种方式，它将共享的值通过channel传递。在任何时刻，最好只有一个goroutine可以拥有该资源。数据竞争在设计层面被消除。 常用的并发编程模型有多线程模型、消息传递模型等。golang是基于消息并发实现其并发特性的，其将CSP并发编程模型内置到了语言中。与Erlang不同的是，golang的goroutine是由go这个关键字创建的共享内存。 Golang并发编程的slogan： Do not communicate by sharing memory; instead, share memory by communicating. go协程与系统线程 go协程(goroutine)是一种轻量级的线程。启动一个go协程，不仅简单如调用一个函数，而且启动的开销非常小，协程之间的调度成本也非常低。 go协程与系统线程的差别 go协程与系统线程的差别只是一个变量，但正是这个变量的区别导致了go并发编程的质的飞跃。 **系统级线程：**具有固定的栈大小(通常默认是2MB)，该栈主要用于在递归调用函数时保存参数和局部变量。固定栈大小会导致两个问题：一是对许多只需要少量栈空间的线程来说是一种巨大的浪费；二是需要大量栈空间的线程会面临栈溢出的风险。 **go协程：**goroutine以一个非常小的栈启动，栈大小不固定，可动态伸缩(最多为1GB)。因此启动成本非常小，所以可以启动成千上万个goroutine。 goroutine的调度器 goroutine采用半抢占式的协作调度，只有在当前goroutine被阻塞时才会导致调度。同时，它发生在用户模式下。调度器会根据具体函数只保存必要的寄存器，切换成本远低于系统线程。运行时有一个runtime.GOMAXPROCS变量，用于控制当前运行正常非阻塞Goroutine的系统线程数。 关于goroutine的调度器的详细说明请参阅：&lt;(https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/&gt; References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-12-01-golang-basics-introductory-remarks/"},{"title":"Go语言基础(二) -- string","content":"与数组不同，字符串中的元素是不可修改的，字符串是一个只读字节数组。虽然字符串的长度一旦固定就不可修改，但长度并不是字符串类型的一部分。 由于Go的源码需要UTF8编码，所以出现在Go源码中的字符串常量通常是UTF8编码的。 golang中的字符串底层数据结构为reflect.StringHeader： type StringHeader struct { Data uintptr Len int } The string structure consisits of two pieces of information: the first is the underlying byte array pointed by the string, and the second is the length of the string in bytes. The string is actually a structure, so the assignment of the string is the copy process of the reflect.StringHeader structure, and does not involve the copy of the underlying byte array. 字符串结构包含两段信息：第一段是字符串所指向的底层字节数组；第二段是字符串的字节长度。字符串实际上是一个结构，所以字符串的赋值是 reflect.StringHeader结构的拷贝过程，修改赋值后的字符串并不会改变源字符串。 字符串&quot;Hello, World&quot; 对应的内存结构如图： 虽然字符串不是切片，但是也支持针对切片的操作： s := &quot;hello, world&quot; hello := s[:5] world := s[7:] 字符串可以转换成byte[] 和 rune[]，且可使用for range 去遍历字符串。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-11-29-golang-basics-string/"},{"title":"游戏开发中的设计模式(一) -- 命令模式","content":"A command is a reified method call. 使用场景示例 输入处理 每个游戏都有一处代码块用来处理用户原始的输入，如：按钮点击、键盘事件、鼠标点击等。 它会记录输入并转换为游戏中的一个动作。 简单实现： void InputHandler::handleInput() { if (isPressed(BUTTON_X)) jump(); else if (isPressed(BUTTON_Y)) fire(); else if (isPressed(BUTTON_A)) swapWeapon(); else if (isPressed(BUTTON_B)) lurchInffectively(); } 上述代码是有效的，但是如今许多游戏允许用户自定义按钮与游戏行为之间的映射关系。 所以，为了支持自定义，我们需要把对jump()、fire()等方法的直接调用转换为可更换的东西。 因此我们需要使用对象来代表一个游戏动作。这就用到了命令模式。 首先，定义一个基类，代表一个可触发的游戏命令： class Command { public: virtual ~Command() {} virtual void execute() = 0; }; 然后为每一个不同的游戏动作创建一个子类： class JumpCmd : public Command { public: virtual void execute() { jump(); } }; class FireCmd : public Command { virtual void execute() { fire(); } }; /// #TODO: add more action subclass . . . 在输入处理中，为每个按钮存储一个指向命令的指针： class InputHandler { public: void handleInput(); /// #TODO: method to bind commands . . . private: Command* button_X; Command* button_Y; Command* button_A; Command* button_B; }; 现在对输入的处理便通过这些指针进行代理： void InputHandler::handleInput() { if (isPressed(BUTTON_X)) button_X-&gt;execute(); else if (isPressed(BUTTON_Y) button_Y-&gt;execute(); else if (isPressed(BUTTON_A) button_A-&gt;execute(); else if (isPressed(BUTTON_B) button_B-&gt;execute(); } 之前每个输入都会直接调用一个函数，现在则增加了一个间接调用层。 解耦角色和命令 在上例中，这些命令的使用范围很窄，只能作用于玩家对象。现在，让我们放宽限制，传入任何一个我们想要控制的对象，而不是让命令自身来确定所控制的对象： class Command { public: virtual ~Command() {} virtual void execute(GameActor&amp; actor) = 0; }; class JumpCmd : public Command { public: virtual void execute(GameActor&amp; actor) { actor.jump(); } }; 接下来修改输入处理方法，使其返回一个命令实例，以便调用具体的execute()： Command* InputHandler::handleInput() { if (isPressed(BUTTON_X)) return button_X; if (isPressed(BUTTON_Y)) return button_Y; if (isPressed(BUTTON_A)) return button_A; if (isPressed(BUTTON_B)) return button_B; return NULL; } 最终，对输入的处理转化为动作的映射代码如下： Command* cmd = inputHandler.handleInput(); if (cmd) { cmd-&gt;execute(actor); } undo&amp;redo 命令模式一个重要的应用就是“撤销操作”。因为命令对象可以do一些事，那么就应该能够轻松地undo它们。这在游戏中应用广泛，比如策略游戏中的回滚操作，以及一些游戏的重播功能。 上述例子中，我们希望从被操控的角色中抽象出命令，以便角色和命令解耦；但在这个例子中，我们希望将命令绑定到被移动的角色上，以便能够实现角色动作的回滚。 示例代码： 封装移动操作： class MoveUnitCmd : public Command { public: MoveUnitCmd(Unit* unit, int x, int y) : mUnit(uint), mX(x), mY(y) {} virtual void execute() { mUnit-&gt;moveTo(mX, mY); } private: Unit* mUnit; int mX; int mY; }; 之前的输入处理程序仅维护单一的命令对象，并在对应按钮被按下时调用其execute()方法。但这里，命令将更加具体，这意味着每次玩家选择一个动作，输入处理程序代码都会创建一个命令实例： Command* handleInput() { Unit* unit = getSelectedUnit(); if (isPressed(BUTTON_UP)) { int destY = unit-&gt;y() - 1; return new MoveUnitCmd(unit, unit-&gt;x(), destY); } if (isPressed(BUTTON_DOWN)) { int destY = unit-&gt;y() + 1; return new MoveUnitCmd(unit, unit-&gt;x(), destY); } /// #TODO: others moves . . . return NULL; } Command类新增undo方法： class Command { public: virtual ~Command() {} virtual void execute() = 0; virtual void undo() = 0; } 进一步，修改上述子类，实现undo方法： class MoveUnitCmd : public Command { public: MoveUnitCmd(Unit* unit, int x, int y) : mUnit(unit), mX(x), mY(y), xBefore(0), yBefore(0), {} virtual void execute() { // remember the unit's position before the move xBefore = mUnit-&gt;x(); yBefore = mUnit-&gt;y(); mUnit-&gt;moveTo(mX, mY); } virtual undo() { mUnit-&gt;moveTo(xBefore, yBefore); } private: Unit* mUnit; int mX, mY; int xBefore, yBefore; } 更进一步，可以支持多次撤销。 具体思路是：不再只保存最后一个命令，而是维护一个命令列表和一个对当前命令的一个引用。当玩家执行了一个命令，就把该命令添加到这个列表，并将当前指针指向它。 当玩家选择undo时，我们撤销当前的命令并将当前指针移回去；当选择redo时，将当前指针移回去，然后从此处开始执行列表中的命令。如果撤销之后选择了一个新命令，则列表中位于当前命令之后的所有命令都被舍弃掉。 References: Game Programming Patterns ","link":"https://TomorrowTown.github.io/post/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi/"},{"title":"Go语言基础(一) -- array","content":"数组是一种固定长度的序列，可包含0个或多个元素。值得注意的是，长度也是决定数组类型的因素。数组由不同长度或不同类型的数据组成，那么这些数组就是不同的类型，是不能直接赋值的。因此在实际的golang项目中很少使用数组。对应于数组的类型是slice，slice是一种可以动态增长和收缩的序列，本章暂且不表。 var a [3]int // define an int-type array of length 3, all the elements are 0 var b = [...]int{1, 2, 3} // define an int-type array of length 3, elements are 1, 2, 3 var c = [...]int{2: 3, 1: 2} // define an int-type of length 3, elements are 0, 2, 3 var d = [...]int{1, 2, 4: 5, 6} // define an int-type of length 3, elements are 1, 2, 0, 0, 5, 6, /* 值得注意的是第三种和第四种方法去定义一个数组。 第三种方法：golang支持数组中的元素通过索引去初始化，因此初始化时不必按照索引从0开始递增的方式去初始化。数组的长度基于初始化时出现的最大索引，未显式初始化的元素仍然使用0值初始化。 第四种方法：混合了第四种和第三种初始化方法。 */ 内存结构： golang中的数组是值语义的。一个数组变量代表的是整个数组，不像C++，代表的是数组第一个元素的指针。当一个数组被赋值或是被传递，整个数组其实是被拷贝的，修改拷贝的数组并不会改变原数组的数据，因为他们并不共享底层数据结构。 如果数组很大，那么数组分配也会有很大的开销。为了避免复制数组的开销，可以传递一个指向数组的指针，但数组指针不是数组。 var a = [...]int{1, 2, 3} var b = &amp;a fmt.Println(a[0], a[1]) // Prints the first two elements of the array fmt.Println(b[0], b[1]) // Accessing array elements through array pointer is similar to arrays // Iterate through the elements of an array through array pointer. for i, v = range b { ...... } 遍历数组的常用方法 for i := range a { } for i, v := range a { } for i := 0 ; i &lt; len(a); i++ { } 需要注意的是，使用for range的方式进行遍历，其性能要比传统的**for i := 0 ; i &lt; len(a); i++ **要差很多。具体原因请查看：https://www.flysnow.org/2018/10/20/golang-for-range-slice-map.html 数组的其他用途 数组不仅可以用于数字类型，还可以是字符串数组，结构体数组，函数数组，接口数组，管道数组等等： // string array var s1 = [...]string{&quot;hello&quot;, &quot;world&quot;} // structure array var line = [...]image.point{{0, 0}, {1, 1}} // function array var decoder = [...]func(io.Reader) (image.Image, error) { png.Decode, jpeg.Decode, } // interface array var unknown = [...]interface{}{123, &quot;hello&quot;} // pipe array var chanList = [2]chan int{} 也可以定义空数组： var d = [0]int var e = [0]int{} var f = [...]int{} 长度为0的数组不占用内存空间。虽然空数组很少被使用，但它们可以用来强调某些类型的操作，以避免分配额外的内存空间，例如管道同步操作： c1 := make(chan [0]int) go func() { fmt.Println(&quot;c1&quot;) c1 &lt;- [0]int{} }() &lt;- c1 此处我们不关心管道中传输的实际数据类型，管道中的接收和发送操作仅用于消息同步。对于这个应用场景，我们使用一个空数组作为管道类型，以减少分配管道元素的开销。 当然，通常更倾向于使用无类型的匿名结构体以达到相同的目的： c2 := make(chan struct{}) go func() { fmt.Println(&quot;c2&quot;) c2 &lt;- struct{}{} // The part of 'struc{}' means type, and the '{}' represents the value of the structure }() &lt;- c2 在golang中，数组是切片和字符串的基础结构。数组的许多操作都可直接用于切片和字符串。 References: Advanced Go Programming ","link":"https://TomorrowTown.github.io/post/2020-11-12-golang-basics-array/"},{"title":"go服务器性能分析方法","content":"pprof 在需要监测的server源码中的main或init中引入: import _ &quot;net/http/pprof&quot; 启动http监听端口，以此作为性能分析数据展示网页。 go http.ListenAndServe(&quot;:9999&quot;, nil) 这样，默认访问地址为localhost:9999。 无论是否是http服务, 都可以引入net/http/pprof作为性能分析的工具。 go-torch和FlameGraph 安装go-torch和FlameGraph go get github.com/uber/go-torch cd $GOPATH/src/github.com/uber/go-torch git clone https://github.com/brendangregg/FlameGraph.git sudo cp ./FlameGraph/flamegraph.pl /usr/local/bin **NOTE: **go get到的项目默认会放到用户目录下的go文件夹，以此作为该项目的GOPATH。 可能遇到的问题: go get github.com/uber/go-torch时，有可能出现： unrecognized import path &quot;golang.org/x/sys/unix&quot;: https fetch: Get . . . . . . i/o timeout 此时需要: mkdir -p $GOPATH/src/golang.org.x cd $GOPATH/src/golang.org/x git clone https://github.com/golang/sys.git 即可 安装包管理工具 glide用于编译上述下载的go-torch。 go get github.com/Masterminds/glide cd $GOPATH/src/github.com/uber/go-torch glide install 可能遇到的问题: 在glide install时可能出现: 直接无视即可。 运行测试用例 ...... go-torch]$ go test ./... 可能遇到的问题: 出现一堆编译报错。但只要下列语句都没fail, 即可无视其他报错： 最后需要到GOPATH的bin目录下查看是否生成了go-torch可执行文件, 有则成功 运行go-torch获取火焰图 在成功完成了上述所有步骤后，在任意文件夹下都可运行 go-torch命令了。 例： go-torch -u http://localhost:9999 -t 30 -f perf.svg 等待30s，在运行命令的目录下就会生成一份perf.svg（默认是torch.svg）文件, 直接网页打开(实测chome/Edge可正常打开并可点击方块zoom in)该文件即可看到火焰图： 进一步寻找性能痛点 再次用相同的测试条件测试，不过现在仅需要运行： go tool pprof --seconds 60 http://localhost:9999/debug/pprof/profile 60s后会得到cpu分析文件，此时不再是火焰图。 根据之前获得的火焰图，找到不应该占用那么多CPU但是却占用了那么多的方法。 在命令行窗口(pprof)后输入list 方法名， 如果找到了具体哪一步消耗的cpu高，如果该步是另一个包的方法，也无所谓，直接list 方法名即可。 (ps: 输入exit可退出go tool pprof) 会得到该方法中具体哪一步cpu消耗的值，进而得到了该方法的性能痛点。 最后就着手优化吧:) Tips：火焰图中，纵轴从下到上代表调用顺序，横轴每个方块的长度代表占用CPU的时长百分比。 ","link":"https://TomorrowTown.github.io/post/2020-11-05-go-server-performance-analyze/"}]}