<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://TomorrowTown.github.io</id>
    <title>tomorrow</title>
    <updated>2020-11-16T17:09:01.417Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://TomorrowTown.github.io"/>
    <link rel="self" href="https://TomorrowTown.github.io/atom.xml"/>
    <subtitle>Remember to look up at the stars and not on your feet.</subtitle>
    <logo>https://TomorrowTown.github.io/images/avatar.png</logo>
    <icon>https://TomorrowTown.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, tomorrow</rights>
    <entry>
        <title type="html"><![CDATA[游戏开发中的设计模式(一) -- 命令模式]]></title>
        <id>https://TomorrowTown.github.io/post/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi/</id>
        <link href="https://TomorrowTown.github.io/post/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi/">
        </link>
        <updated>2020-11-16T15:02:55.000Z</updated>
        <content type="html"><![CDATA[<p>A command is a reified method call.</p>
<h2 id="使用场景示例"><strong>使用场景示例</strong></h2>
<h3 id="输入处理"><strong>输入处理</strong></h3>
<p>每个游戏都有一处代码块用来处理用户原始的输入，如：按钮点击、键盘事件、鼠标点击等。<br>
它会记录输入并转换为游戏中的一个动作。<br>
简单实现：</p>
<pre><code class="language-cpp">void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) jump();
    else if (isPressed(BUTTON_Y)) fire();
    else if (isPressed(BUTTON_A)) swapWeapon();
    else if (isPressed(BUTTON_B)) lurchInffectively();
}
</code></pre>
<p>上述代码是有效的，但是如今许多游戏允许用户自定义按钮与游戏行为之间的映射关系。<br>
所以，为了支持自定义，我们需要把对jump()、fire()等方法的直接调用转换为<strong>可更换的</strong>东西。<br>
因此我们需要使用对象来代表一个游戏动作。这就用到了命令模式。<br>
首先，定义一个基类，代表一个可触发的游戏命令：</p>
<pre><code class="language-cpp">class Command
{
public:
    virtual ~Command() {}
    virtual void execute() = 0;    
};
</code></pre>
<p>然后为每一个不同的游戏动作创建一个子类：</p>
<pre><code class="language-cpp">class JumpCmd : public Command
{
public:
    virtual void execute() { jump(); }
};

class FireCmd : public Command
{
    virtual void execute() { fire(); }
};

/// #TODO: add more action subclass . . .
</code></pre>
<p>在输入处理中，为每个按钮存储一个指向命令的指针：</p>
<pre><code class="language-cpp">class InputHandler
{
public:
    void handleInput();

    ///  #TODO: method to bind commands . . .

private:
    Command* button_X;
    Command* button_Y;
    Command* button_A;
    Command* button_B;
};
</code></pre>
<p>现在对输入的处理便通过这些指针进行<strong>代理</strong>：</p>
<pre><code class="language-cpp">void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) button_X-&gt;execute();
    else if (isPressed(BUTTON_Y) button_Y-&gt;execute();
    else if (isPressed(BUTTON_A) button_A-&gt;execute();
    else if (isPressed(BUTTON_B) button_B-&gt;execute();
}
</code></pre>
<p>之前每个输入都会直接调用一个函数，现在则增加了一个间接调用层。</p>
<h4 id="解耦角色和命令"><strong>解耦角色和命令</strong></h4>
<p>在上例中，这些命令的使用范围很窄，只能作用于玩家对象。现在，让我们放宽限制，传入任何一个我们想要控制的对象，而不是让命令自身来确定所控制的对象：</p>
<pre><code class="language-cpp">class Command
{
public:
    virtual ~Command() {}
    virtual void execute(GameActor&amp; actor) = 0;
};

class JumpCmd : public Command
{
public:
    virtual void execute(GameActor&amp; actor) { actor.jump(); }
};
</code></pre>
<p>接下来修改输入处理方法，使其返回一个命令实例，以便调用具体的execute()：</p>
<pre><code class="language-cpp">Command* InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) return button_X;
    if (isPressed(BUTTON_Y)) return button_Y;
    if (isPressed(BUTTON_A)) return button_A;
    if (isPressed(BUTTON_B)) return button_B;

    return NULL;
}
</code></pre>
<p>最终，对输入的处理转化为动作的映射代码如下：</p>
<pre><code class="language-cpp">Command* cmd = inputHandler.handleInput();
if (cmd) { cmd-&gt;execute(actor); }
</code></pre>
<h3 id="undoredo"><strong>undo&amp;redo</strong></h3>
<p>命令模式一个重要的应用就是“撤销操作”。因为命令对象可以<strong>do</strong>一些事，那么就应该能够轻松地<strong>undo</strong>它们。这在游戏中应用广泛，比如策略游戏中的回滚操作，以及一些游戏的重播功能。<br>
与上述例子中，我们希望从被操控的角色中抽象出命令，以便角色和命令解耦；但在这个例子中，我们希望<u>将命令绑定到被移动的角色</u>上，以便能够实现角色动作的回滚。<br>
示例代码：<br>
封装移动操作：</p>
<pre><code class="language-cpp">class MoveUnitCmd : public Command
{
public:
    MoveUnitCmd(Unit* unit, int x, int y) : mUnit(uint), mX(x), mY(y) {}
    virtual void execute() { mUnit-&gt;moveTo(mX, mY); }

private:
    Unit* mUnit;
    int mX;
    int mY;
};
</code></pre>
<p>之前的输入处理程序仅维护单一的命令对象，并在对应按钮被按下时调用其execute()方法。但这里，命令将更加具体，这意味着每次玩家选择一个动作，输入处理程序代码都会创建一个命令实例：</p>
<pre><code class="language-cpp">Command* handleInput()
{
    Unit* unit = getSelectedUnit();

    if (isPressed(BUTTON_UP)) {
        int destY = unit-&gt;y() - 1;
        return new MoveUnitCmd(unit, unit-&gt;x(), destY);
    }

    if (isPressed(BUTTON_DOWN)) {
        int destY = unit-&gt;y() + 1;
        return new MoveUnitCmd(unit, unit-&gt;x(), destY);
    }

    /// #TODO: others moves . . .

    return NULL;
}
</code></pre>
<p>Command类新增undo方法：</p>
<pre><code class="language-cpp">class Command
{
public:
    virtual ~Command() {}
    virtual void execute() = 0;
    virtual void undo() = 0;
}
</code></pre>
<p>进一步，修改上述子类，实现undo方法：</p>
<pre><code class="language-cpp">class MoveUnitCmd : public Command
{
public:
    MoveUnitCmd(Unit* unit, int x, int y)
    : mUnit(unit), mX(x), mY(y),
      xBefore(0), yBefore(0),
    {}

    virtual void execute()
    {
        // remember the unit's position before the move
        xBefore = mUnit-&gt;x();
        yBefore = mUnit-&gt;y();
        mUnit-&gt;moveTo(mX, mY);
    }

    virtual undo()
    {
        mUnit-&gt;moveTo(xBefore, yBefore);
    }

private:
    Unit* mUnit;
    int mX, mY;
    int xBefore, yBefore;
}
</code></pre>
<p>更进一步，可以支持多次撤销。<br>
具体思路是：不再只保存最后一个命令，而是维护一个命令列表和一个对当前命令的一个引用。当玩家执行了一个命令，就把该命令添加到这个列表，并将当前指针指向它。<br>
当玩家选择undo时，我们撤销当前的命令并将当前指针移回去；当选择redo时，将当前指针移回去，然后从此处开始执行后续的命令。如果撤销之后选择了一个新命令，则列表中位于当前命令之后的所有命令都被舍弃掉。</p>
<blockquote>
<p>References:<br>
[1] Robert Nystrom. Game Programming Patterns[M]. 北京: 人民邮电出版社, 2016.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang Basics--Array]]></title>
        <id>https://TomorrowTown.github.io/post/golang-basics-array/</id>
        <link href="https://TomorrowTown.github.io/post/golang-basics-array/">
        </link>
        <updated>2020-11-12T13:50:51.000Z</updated>
        <content type="html"><![CDATA[<p>Array is a sequence of fixed-lenth elements of a specific type, An array can consist of zero or more elements. The length of the array <u>is a part of array type,</u> array composed of different lengths or different types of data are diffenrent types, so arrays are rarely used directly in Go language(arrays of different lengths cannot be directly assigned because of different types). The type corresponding to the array is a slice, a slice is a sequence that can grow and shrink dynamically.</p>
<pre><code class="language-Go">var a [3]int                        // define an int-type array of length 3, all the elements are 0
var b = [...]int{1, 2, 3}           // define an int-type array of length 3, elements are 1, 2, 3
var c = [...]int{2: 3, 1: 2}        // define an int-type of length 3, elements are 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6}     // define an int-type of length 3, elements are 1, 2, 0, 0, 5, 6, 

/*
Pay attention to the 3rd and 4th ways to define an array.
The 3rd way: The elements of the array are initialized by index, so the order in which the element's initialization values appear is arbitrary. This initialization method is similar to the initialization syntax of map [int]Type. The length of the array is based on the largest index that apppears, and elements that are not explicitly initialized are still initialized with a value of 0.
The 4th way: Mixing the second and third initialization methods.
*/
</code></pre>
<p><em>Memory structure:</em><br>
<img src="https://TomorrowTown.github.io/post-images/1605189729922.png" alt="" loading="lazy"></p>
<p>Arrays in Go are value sementics. <u>An array variable represents the entire array. It is not an implicit pointer to the first element</u>(such as an array in C), but a complete value. When an array variable is assigned or passed, <u>the entire array is actually copied.</u><br>
If the array is large, the assignment of the array will also have a large overhead. To avoid the overhead of copying an array, you can pass a pointer to the array, but <u>the array pointer is not an array.</u></p>
<pre><code class="language-Go">var a = [...]int{1, 2, 3}
var b = &amp;a

fmt.Println(a[0], a[1])     // Prints the first two elements of the array
fmt.Println(b[0], b[1])     // Accessing array elements through array pointer is similar to arrays

// Iterate through the elements of an array through array pointer.
for i, v = range b {
    ......
}
</code></pre>
<h2 id="common-ways-to-traverse-an-array">Common ways to traverse an array</h2>
<pre><code class="language-Go">for i := range a {
}
for i, v := range a {
}
for i := 0 ; i &lt; len(a); i++ {
}
</code></pre>
<p>The performance of <strong>for range</strong> may be better, because this iteration can ensure that the array does not exceed the boundary, and the iteration of the array element can be omitted from the judgement of the subscript boundary.</p>
<h2 id="more-uses-for-array">More uses for array</h2>
<p>Array can be used not only for numeric types, but also string array, structure array, function array, interface array, pipe array, etc:</p>
<pre><code class="language-Go">// string array
var s1 = [...]string{&quot;hello&quot;, &quot;world&quot;}

// structure array
var line = [...]image.point{{0, 0}, {1, 1}}

// function array
var decoder = [...]func(io.Reader) (image.Image, error) {
    png.Decode,
    jpeg.Decode,
}
// interface array
var unknown = [...]interface{}{123, &quot;hello&quot;}

// pipe array
var chanList = [2]chan int{}
</code></pre>
<p>We can also define an empty array:</p>
<pre><code class="language-Go">var d = [0]int
var e = [0]int{}
var f = [...]int{}
</code></pre>
<p>An array of length 0 does not occupy space in memory. Although empty array is rarely used directly, they can be used to emphasize certain types of operations to avoid allocating additional memory space, such as for pipeline synchronization operations:</p>
<pre><code class="language-Go">c1 := make(chan [0]int)
go func() {
    fmt.Println(&quot;c1&quot;)
    c1 &lt;- [0]int{}
}()
&lt;- c1
</code></pre>
<p>Here, we do not care about the actual type of data transmitted in the pipeline, where the pipeline receive and send operations are only used for message synchronization. For this scenario, we use an empty array as the pipeline type to reduce the overhead of pipeline element assignment. Of course, it is generally more preferred to use typeless anonymous structure instead.</p>
<pre><code class="language-Go">c2 := make(chan struct{})
go func() {
    fmt.Println(&quot;c2&quot;)
    c2 &lt;- struct{}{}    // The part of 'struc{}' means type, and the '{}' represents the value of the structure
}()
&lt;- c2
</code></pre>
<p>In Go, array types are the basis of structures such as slices and string. Many operations obove of the array can be use directly for string or slice.</p>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go服务器性能分析工具]]></title>
        <id>https://TomorrowTown.github.io/post/go-fu-wu-qi-xing-neng-fen-xi-gong-ju/</id>
        <link href="https://TomorrowTown.github.io/post/go-fu-wu-qi-xing-neng-fen-xi-gong-ju/">
        </link>
        <updated>2020-11-05T14:32:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pprof">pprof</h2>
<ol>
<li>在需要监测的server源码中的main或init中引入:</li>
</ol>
<pre><code class="language-go">import _ &quot;net/http/pprof&quot;
</code></pre>
<ol start="2">
<li>启动http监听端口，以此作为性能分析数据展示网页。</li>
</ol>
<pre><code class="language-go">go http.ListenAndServe(&quot;:9999&quot;, nil)
</code></pre>
<p>这样，默认访问地址为localhost:9999。</p>
<blockquote>
<p>无论是否是http服务, 都可以引入**&quot;net/http/pprof&quot;**作为性能分析的工具。</p>
</blockquote>
<h2 id="go-torch和flamegraph">go-torch和FlameGraph</h2>
<ol>
<li>安装go-torch和FlameGraph</li>
</ol>
<pre><code class="language-shell">go get github.com/uber/go-torch
cd $GOPATH/src/github.com/uber/go-torch
git clone https://github.com/brendangregg/FlameGraph.git
sudo cp ./FlameGraph/flamegraph.pl /usr/local/bin
</code></pre>
<p>NOTE: go get到的项目默认会放到用户目录下的go文件夹，以此作为该项目的GOPATH。</p>
<blockquote>
<p>可能遇到的问题:<br>
go get github.com/uber/go-torch时，有可能出现：</p>
<pre><code class="language-shell">unrecognized import path &quot;golang.org/x/sys/unix&quot;: https fetch: Get . . . . . . i/o timeout
</code></pre>
<p>此时需要:</p>
<pre><code class="language-shell">mkdir -p $GOPATH/src/golang.org.x
cd $GOPATH/src/golang.org/x
git clone https://github.com/golang/sys.git 即可
</code></pre>
</blockquote>
<ol start="2">
<li>安装包管理工具<br>
glide用于编译上述下载的go-torch。</li>
</ol>
<pre><code class="language-shell">go get github.com/Masterminds/glide
cd $GOPATH/src/github.com/uber/go-torch
glide install
</code></pre>
<blockquote>
<p>可能遇到的问题:<br>
在glide install时可能出现:<br>
<img src="https://TomorrowTown.github.io/post-images/1604588907765.png" alt="" loading="lazy"><br>
直接无视即可。</p>
</blockquote>
<ol start="3">
<li>运行测试用例</li>
</ol>
<pre><code class="language-shell">...... go-torch]$ go test ./...
</code></pre>
<blockquote>
<p>可能遇到的问题:<br>
出现一堆编译报错。但只要下列语句都没fail, 即可无视其他报错：<br>
<img src="https://TomorrowTown.github.io/post-images/1604588991700.png" alt="" loading="lazy"><br>
最后需要到GOPATH的bin目录下查看是否生成了<strong>go-torch</strong>可执行文件, 有则成功</p>
</blockquote>
<h2 id="运行go-torch获取火焰图">运行go-torch获取火焰图</h2>
<p>在成功完成了上述所有步骤后，在任意文件夹下都可运行 go-torch命令了。<br>
例：</p>
<pre><code class="language-shell">go-torch -u http://localhost:9999 -t 30 -f perf.svg
</code></pre>
<p>等待30s，在运行命令的目录下就会生成一份perf.svg（默认是torch.svg）文件, 直接网页打开(实测chome/Edge可正常打开并可点击方块zoom in)该文件即可看到火焰图：<br>
<img src="https://TomorrowTown.github.io/post-images/1604589121478.png" alt="" loading="lazy"></p>
<h2 id="进一步寻找性能痛点">进一步寻找性能痛点</h2>
<p>再次用相同的测试条件测试，不过现在仅需要运行：</p>
<pre><code class="language-shell">go tool pprof --seconds 60 http://localhost:9999/debug/pprof/profile
</code></pre>
<p>60s后会得到cpu分析文件，此时不再是火焰图。<br>
根据之前获得的火焰图，找到不应该占用那么多CPU但是却占用了那么多的方法。<br>
在命令行窗口(pprof)后输入<strong>list 方法名</strong>，<br>
如果找到了具体哪一步消耗的cpu高，如果该步是另一个包的方法，也无所谓，直接<strong>list 方法名</strong>即可。<br>
(ps: 输入exit可退出go tool pprof)<br>
会得到该方法中具体哪一步cpu消耗的值，进而得到了该方法的性能痛点。<br>
最后就着手优化吧:)</p>
<p><strong>Tips：<strong>火焰图中，纵轴从下到上代表</strong>调用顺序</strong>，横轴每个方块的长度代表<strong>占用CPU的时长百分比</strong>。</p>
]]></content>
    </entry>
</feed>