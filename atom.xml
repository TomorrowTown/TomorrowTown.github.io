<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://TomorrowTown.github.io</id>
    <title>tomorrow</title>
    <updated>2020-11-12T14:07:02.909Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://TomorrowTown.github.io"/>
    <link rel="self" href="https://TomorrowTown.github.io/atom.xml"/>
    <subtitle>Remember to look up at the stars and not on your feet.</subtitle>
    <logo>https://TomorrowTown.github.io/images/avatar.png</logo>
    <icon>https://TomorrowTown.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, tomorrow</rights>
    <entry>
        <title type="html"><![CDATA[Golang Basics--Array]]></title>
        <id>https://TomorrowTown.github.io/post/golang-basics-array/</id>
        <link href="https://TomorrowTown.github.io/post/golang-basics-array/">
        </link>
        <updated>2020-11-12T13:50:51.000Z</updated>
        <content type="html"><![CDATA[<p>Array is a sequence of fixed-lenth elements of a specific type, An array can consist of zero or more elements. The length of the array <u>is a part of array type,</u> array composed of different lengths or different types of data are diffenrent types, so arrays are rarely used directly in Go language(arrays of different lengths cannot be directly assigned because of different types). The type corresponding to the array is a slice, a slice is a sequence that can grow and shrink dynamically.</p>
<pre><code class="language-Go">var a [3]int                        // define an int-type array of length 3, all the elements are 0
var b = [...]int{1, 2, 3}           // define an int-type array of length 3, elements are 1, 2, 3
var c = [...]int{2: 3, 1: 2}        // define an int-type of length 3, elements are 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6}     // define an int-type of length 3, elements are 1, 2, 0, 0, 5, 6, 

/*
Pay attention to the 3rd and 4th ways to define an array.
The 3rd way: The elements of the array are initialized by index, so the order in which the element's initialization values appear is arbitrary. This initialization method is similar to the initialization syntax of map [int]Type. The length of the array is based on the largest index that apppears, and elements that are not explicitly initialized are still initialized with a value of 0.
The 4th way: Mixing the second and third initialization methods.
*/
</code></pre>
<p><em>Memory structure:</em><br>
<img src="https://TomorrowTown.github.io/post-images/1605189729922.png" alt="" loading="lazy"></p>
<p>Arrays in Go are value sementics. <u>An array variable represents the entire array. It is not an implicit pointer to the first element</u>(such as an array in C), but a complete value. When an array variable is assigned or passed, <u>the entire array is actually copied.</u><br>
If the array is large, the assignment of the array will also have a large overhead. To avoid the overhead of copying an array, you can pass a pointer to the array, but <u>the array pointer is not an array.</u></p>
<pre><code class="language-Go">var a = [...]int{1, 2, 3}
var b = &amp;a

fmt.Println(a[0], a[1])     // Prints the first two elements of the array
fmt.Println(b[0], b[1])     // Accessing array elements through array pointer is similar to arrays

// Iterate through the elements of an array through array pointer.
for i, v = range b {
    ......
}
</code></pre>
<h2 id="common-ways-to-traverse-an-array">Common ways to traverse an array</h2>
<pre><code class="language-Go">for i := range a {
}
for i, v := range a {
}
for i := 0 ; i &lt; len(a); i++ {
}
</code></pre>
<p>The performance of <strong>for range</strong> may be better, because this iteration can ensure that the array does not exceed the boundary, and the iteration of the array element can be omitted from the judgement of the subscript boundary.</p>
<h2 id="more-uses-for-array">More uses for array</h2>
<p>Array can be used not only for numeric types, but also string array, structure array, function array, interface array, pipe array, etc:</p>
<pre><code class="language-Go">// string array
var s1 = [...]string{&quot;hello&quot;, &quot;world&quot;}

// structure array
var line = [...]image.point{{0, 0}, {1, 1}}

// function array
var decoder = [...]func(io.Reader) (image.Image, error) {
    png.Decode,
    jpeg.Decode,
}
// interface array
var unknown = [...]interface{}{123, &quot;hello&quot;}

// pipe array
var chanList = [2]chan int{}
</code></pre>
<p>We can also define a empty array:</p>
<pre><code class="language-Go">var d = [0]int
var e = [0]int{}
var f = [...]int{}
</code></pre>
<p>An array of length 0 does not occupy space in memory. Although empty array is rarely used directly, they can be used to emphasize certain types of operations to avoid allocating additional memory space, such as for pipeline synchronization operations:</p>
<pre><code class="language-Go">c1 := make(chan [0]int)
go func() {
    fmt.Println(&quot;c1&quot;)
    c1 &lt;- [0]int{}
}()
&lt;- c1
</code></pre>
<p>Here, we do not care about the actual type of data transmitted in the pipeline, where the pipeline receive and send operations are only used for message synchronization. For this scenario, we use an empty array as the pipeline type to reduce the overhead of pipeline element assignment. Of course, it is generally more preferred to use typeless anonymous structure instead.</p>
<pre><code class="language-Go">c2 := make(chan struct{})
go func() {
    fmt.Println(&quot;c2&quot;)
    c2 &lt;- struct{}{}    // The part of 'struc{}' means type, and the '{}' represents the value of the structure
}()
&lt;- c2
</code></pre>
<p>In Go, array types are the basis of structures such as slices and string. Many operations obove of the array can be use directly for string or slice.</p>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">《Advanced Go Programming》</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go服务器性能分析工具]]></title>
        <id>https://TomorrowTown.github.io/post/go-fu-wu-qi-xing-neng-fen-xi-gong-ju/</id>
        <link href="https://TomorrowTown.github.io/post/go-fu-wu-qi-xing-neng-fen-xi-gong-ju/">
        </link>
        <updated>2020-11-05T14:32:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pprof">pprof</h2>
<ol>
<li>在需要监测的server源码中的main或init中引入:</li>
</ol>
<pre><code class="language-go">import _ &quot;net/http/pprof&quot;
</code></pre>
<ol start="2">
<li>启动http监听端口，以此作为性能分析数据展示网页。</li>
</ol>
<pre><code class="language-go">go http.ListenAndServe(&quot;:9999&quot;, nil)
</code></pre>
<p>这样，默认访问地址为localhost:9999。</p>
<blockquote>
<p>无论是否是http服务, 都可以引入**&quot;net/http/pprof&quot;**作为性能分析的工具。</p>
</blockquote>
<h2 id="go-torch和flamegraph">go-torch和FlameGraph</h2>
<ol>
<li>安装go-torch和FlameGraph</li>
</ol>
<pre><code class="language-shell">go get github.com/uber/go-torch
cd $GOPATH/src/github.com/uber/go-torch
git clone https://github.com/brendangregg/FlameGraph.git
sudo cp ./FlameGraph/flamegraph.pl /usr/local/bin
</code></pre>
<p>NOTE: go get到的项目默认会放到用户目录下的go文件夹，以此作为该项目的GOPATH。</p>
<blockquote>
<p>可能遇到的问题:<br>
go get github.com/uber/go-torch时，有可能出现：</p>
<pre><code class="language-shell">unrecognized import path &quot;golang.org/x/sys/unix&quot;: https fetch: Get . . . . . . i/o timeout
</code></pre>
<p>此时需要:</p>
<pre><code class="language-shell">mkdir -p $GOPATH/src/golang.org.x
cd $GOPATH/src/golang.org/x
git clone https://github.com/golang/sys.git 即可
</code></pre>
</blockquote>
<ol start="2">
<li>安装包管理工具<br>
glide用于编译上述下载的go-torch。</li>
</ol>
<pre><code class="language-shell">go get github.com/Masterminds/glide
cd $GOPATH/src/github.com/uber/go-torch
glide install
</code></pre>
<blockquote>
<p>可能遇到的问题:<br>
在glide install时可能出现:<br>
<img src="https://TomorrowTown.github.io/post-images/1604588907765.png" alt="" loading="lazy"><br>
直接无视即可。</p>
</blockquote>
<ol start="3">
<li>运行测试用例</li>
</ol>
<pre><code class="language-shell">...... go-torch]$ go test ./...
</code></pre>
<blockquote>
<p>可能遇到的问题:<br>
出现一堆编译报错。但只要下列语句都没fail, 即可无视其他报错：<br>
<img src="https://TomorrowTown.github.io/post-images/1604588991700.png" alt="" loading="lazy"><br>
最后需要到GOPATH的bin目录下查看是否生成了<strong>go-torch</strong>可执行文件, 有则成功</p>
</blockquote>
<h2 id="运行go-torch获取火焰图">运行go-torch获取火焰图</h2>
<p>在成功完成了上述所有步骤后，在任意文件夹下都可运行 go-torch命令了。<br>
例：</p>
<pre><code class="language-shell">go-torch -u http://localhost:9999 -t 30 -f perf.svg
</code></pre>
<p>等待30s，在运行命令的目录下就会生成一份perf.svg（默认是torch.svg）文件, 直接网页打开(实测chome/Edge可正常打开并可点击方块zoom in)该文件即可看到火焰图：<br>
<img src="https://TomorrowTown.github.io/post-images/1604589121478.png" alt="" loading="lazy"></p>
<h2 id="进一步寻找性能痛点">进一步寻找性能痛点</h2>
<p>再次用相同的测试条件测试，不过现在仅需要运行：</p>
<pre><code class="language-shell">go tool pprof --seconds 60 http://localhost:9999/debug/pprof/profile
</code></pre>
<p>60s后会得到cpu分析文件，此时不再是火焰图。<br>
根据之前获得的火焰图，找到不应该占用那么多CPU但是却占用了那么多的方法。<br>
在命令行窗口(pprof)后输入<strong>list 方法名</strong>，<br>
如果找到了具体哪一步消耗的cpu高，如果该步是另一个包的方法，也无所谓，直接<strong>list 方法名</strong>即可。<br>
(ps: 输入exit可退出go tool pprof)<br>
会得到该方法中具体哪一步cpu消耗的值，进而得到了该方法的性能痛点。<br>
最后就着手优化吧:)</p>
<p><strong>Tips：<strong>火焰图中，纵轴从下到上代表</strong>调用顺序</strong>，横轴每个方块的长度代表<strong>占用CPU的时长百分比</strong>。</p>
]]></content>
    </entry>
</feed>