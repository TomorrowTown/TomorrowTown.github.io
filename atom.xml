<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://TomorrowTown.github.io</id>
    <title>tomorrow</title>
    <updated>2020-12-07T15:00:54.787Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://TomorrowTown.github.io"/>
    <link rel="self" href="https://TomorrowTown.github.io/atom.xml"/>
    <subtitle>&quot;我猪肉佬何尝不想当一个伟大的舞蹈家&quot;</subtitle>
    <logo>https://TomorrowTown.github.io/images/avatar.png</logo>
    <icon>https://TomorrowTown.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, tomorrow</rights>
    <entry>
        <title type="html"><![CDATA[Go语言并发编程模型(六) -- 发布订阅模型]]></title>
        <id>https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-ba-fa-bu-ding-yue-mo-xing/</id>
        <link href="https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-ba-fa-bu-ding-yue-mo-xing/">
        </link>
        <updated>2020-11-29T15:52:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0x00">0x00</h2>
<p>相比于生产者消费者模型而言，消息的生产者在发布订阅模型中充当了消息的发布者(publisher)，消息的消费者充当了消息的订阅者(subscriber)。<br>
在传统的生产者消费者模型中，消息被发送到一个队列中，而在发布订阅模型中，消息被发布给一个主题(topic)。<br>
在发布订阅模型中，每一个消息都被传递给多个订阅者。发布者通常不知道也不关心哪个订阅者收到了主题消息。发布者和订阅者可以在运行时动态地添加，是一种松散的耦合关系，这使得系统地复杂性会随着时间的推移而增长。</p>
<h2 id="一个支持多主题的pub-sub库的简易实现">一个支持多主题的pub-sub库的简易实现</h2>
<pre><code class="language-Go">package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

type (
	// subscriber is a channel
	subscriber chan interface{}
	topicFunc  func(v interface{}) bool
)

// the publisher object
type Publisher struct {
	m               sync.RWMutex
	buffer          int                         // the cache size of subscription queue
	timeout         time.Duration               // publish timeout
	subscribers     map[subscriber]topicFunc    // subscriber information
}

func NewPublisher(timeout time.Duration, buffer int) *Publisher {
	return &amp;Publisher {
		buffer:       buffer,
		timeout:      timeout,
		subscribers:  make(map[subscriber]topicFunc),
	}
}

// add a new subscriber, subscribes all topic
func (p *Publisher) Subscribe() chan interface{} {
	return p.SubscribeTopic(nil)
}

// add a new subscriber, subscribes the topic filtrated by filter
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
	ch := make(chan interface{}, p.buffer)
	p.m.Lock()
	p.subscribers[ch] = topic
	p.m.Unlock()
	return ch
}

func (p *Publisher) Exit(sub chan interface{}) {
	p.m.Lock()
	defer p.m.Unlock()

	delete(p.subscribers, sub)
	close(sub)
}

// publish a topic
func (p *Publisher) Publish(v interface{}) {
	p.m.RLock()
	defer p.m.RUnlock()

	var wg sync.WaitGroup
	for sub, topic := range p.subscribers {
		wg.Add(1)
		go p.SendTopic(sub, topic, v, &amp;wg)
	}
    // wait for all goroutines excute finish
	wg.Wait()
}

// close publisher object, at the same time, close all the channel of subscribers
func (p *Publisher) Close() {
	p.m.Lock()
	defer p.m.Unlock()

	for sub := range p.subscribers {
		delete(p.subscribers, sub)
		close(sub)
	}
}

// send topic, can tolerate a certain timeout
func (p *Publisher) SendTopic(sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup) {
	defer wg.Done()
	if topic != nil &amp;&amp; !topic(v) {
		return
	}
	select {
	case sub &lt;- v:
		// ......
	case &lt;- time.After(p.timeout):
		// ......
	}
}

// test code ...
func main() {
	p := NewPublisher(time.Millisecond * 100, 10)
	defer p.Close()

	all := p.Subscribe()
	gTopic := p.SubscribeTopic(func(v interface{}) bool {
		if s, ok := v.(string); ok {
			return strings.Contains(s, &quot;golang&quot;)
		}
		return false
	})

	// pub
	p.Publish(&quot;hello world!&quot;)
	p.Publish(&quot;hello golang!&quot;)

	// sub
	go func() {
		for msg := range all {
			fmt.Println(&quot;all: &quot;, msg)
		}
	}()

	go func() {
		for msg := range gTopic {
			fmt.Println(&quot;golang: &quot;, msg)
		}
	}()

	// exit after a certain time
	time.Sleep(time.Second * 3)
}
</code></pre>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言并发编程模型(五) -- 生产者消费者模型]]></title>
        <id>https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-qi-sheng-chan-zhe-xiao-fei-zhe-mo-xing/</id>
        <link href="https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-qi-sheng-chan-zhe-xiao-fei-zhe-mo-xing/">
        </link>
        <updated>2020-11-29T15:51:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>talk is cheap, show you the code:</strong></p>
<pre><code class="language-Go">// producer: generate a sequence of multiples of factor
func Producer(factor int, out chan &lt;- int) {
    for i := 0; ; i++ {
        out &lt;- i * factor
    }
} 

// consumer
func Consumer(in &lt;- chan int) {
    for v := range in {
        fmt.Println(v)
    }
}

func main() {
    ch := make(chan int, 64)    // result queue

    // the producers below are concurrency, therefore, the order of the result sequence output by the consumer is uncertain
    go Producer(3, ch)  // generate a sequence of multiples of 3, and put them into the ch
    go Producer(5, ch)  // generate a sequence of multiples of 5, and put them into the ch
    go Consumer(ch)  // consume the generated sequence
    
    // exit after a certain time, let producers and consumers work for a certain time
    // time.Sleep(time.Second * 5)
    
    /*
    * but the above sleep mode cannot guarantee stable output,
    * so we can let the main function save the blocked state without exiting
    * and only exit the program when the user enters &quot;Ctrl C&quot;
    */
    sig := make(chan os.Signal, 1)
    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
    fmt.Println(&quot;quit (%v)\n&quot;, &lt;- sig)
}
</code></pre>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言并发编程模型(四) -- 基于管道的通信]]></title>
        <id>https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-si-ji-yu-guan-dao-de-tong-xin/</id>
        <link href="https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-si-ji-yu-guan-dao-de-tong-xin/">
        </link>
        <updated>2020-11-29T15:47:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0x00">0x00</h2>
<p>依靠channel通信是不同goroutine之间同步的主要方法。</p>
<h2 id="无缓冲channel">无缓冲channel</h2>
<p>对于无缓冲channel而言，每一个发送操作(<strong>chan &lt;- x</strong>)都对应一个接收操作(<strong>&lt;- chan</strong>)，反之亦然。channel的发送和接收操作通常出现在不同的goroutine之间，如果放到同一个goroutine，则很容易出现死锁问题。<br>
使用示例：</p>
<pre><code class="language-Go">var done = make(chan bool)     // define an unbuffered channel, its len and cap always equal to 0
var msg string

func aGoroutine() {
    msg = &quot;hello world&quot;
    done &lt;- x   // sending operation, send a synchronization signal to channel
    // or use close(done) to replace done &lt;- false
}

func main() {
    go aGoroutine()
    &lt;- done     // receiving operation, receive the corresponding synchronization signal
    fmt.println(msg)
}
</code></pre>
<h2 id="有缓冲channel">有缓冲channel</h2>
<p>通过有缓冲channel的buffer大小，我们可以控制并发执行的goroutine的最大数量。例：</p>
<pre><code class="language-Go">var limit = make(chan int, 3)   // the channel with cache, length can be 0, 1, 2 or 3, capacity equals to 3

func main() {
    for _, w := range workerThread {
        go func() {
            limit &lt;- 1
            w()
            &lt;- limit
        }()
        select{}    // empty pipeline selcetion statement, means that only the channel be nil, the main thread can excute return
    }
}
</code></pre>
<p>上述程序允许的最大并发数为3。</p>
<blockquote>
<p><strong>Summary：</strong></p>
<ul>
<li>无缓冲channel：如果线程A向channel进行写操作，线程B尚未对该channel进行读操作，那么A线程将会被阻塞在写操作语句。相应的，如果线程A对一个线程进行读操作，线程B尚未对channel进行写操作，那么A线程将会阻塞在读操作语句。</li>
<li>有缓冲channel：只有当该channel的len==cap时，即该channel满了时，向该channel再进行写操作的化，写操作语句就会被阻塞。如果该channel中无数据(即len=0)，那么读该channel的语句将会被阻塞。</li>
<li>无缓冲channel：实现线程间同步。</li>
<li>有缓冲channel：线程间是异步的。</li>
<li>注意：如果对channel的读和写操作在同一个线程中进行，那么很容易造成读写互相等待，即死锁。</li>
</ul>
</blockquote>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言并发编程模型(三) -- 顺序一致性内存模型]]></title>
        <id>https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-san-shun-xu-yi-zhi-xing-nei-cun-mo-xing/</id>
        <link href="https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-san-shun-xu-yi-zhi-xing-nei-cun-mo-xing/">
        </link>
        <updated>2020-11-29T15:47:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0x00">0x00</h2>
<p>原子操作能够为线程之间的数据同步提供部分保证的前提是<strong>顺序一致性内存模型</strong>。<br>
<u><strong>线程间同步的本质就是为并发的事件进行排序</strong></u>。<br>
以下为一个顺序一致性内存模型：</p>
<pre><code class="language-Go">var a string
var done bool

func set() {
    a = &quot;hello world&quot;
    done = true
}

func main() {
    go set()
    for !done {}
    fmt.Println(a)
}
</code></pre>
<p>在Go语言中，<u>在同一个goroutine内的内存顺序模型能够得到保证</u>(在本例中即：go set()中的a赋值语句一定先于done赋值语句执行)。但是在不同的goroutine中，内存模型的顺序就不能单纯地通过书写顺序去保证了。假如在main线程书写一个done赋值语句，那么就无法保证go set()协程的done赋值语句和main线程的done赋值语句谁先执行了，那么print出来的a就可能为空。<br>
这是因为在Go中，<u>为了使并行最大化，go的编译器和处理器会对语句进行重排，同时CPU也可能会对指令集进行重排</u>。更糟糕的是，main线程可能无法察觉到set协程中的变量变化(可能始终在<a href="https://blog.csdn.net/yangyan1990/article/details/51078301">寄存器</a>内)，进而导致main线程死循环。如果并发程序不能确定事件发生的顺序，那么输出的结果也是不确定的，如以下这个程序：</p>
<pre><code class="language-Go">func main() {
    go fmt.Println(&quot;hello world&quot;)
}
</code></pre>
<p>由于goroutine和return事件是并发的，这两个事件谁都可能先发生，最终是否能打印出hello world也是无法确定的。</p>
<h2 id="使用同步原语进行同步">使用同步原语进行同步</h2>
<pre><code class="language-Go">func main() {
    done := make(chan int)
    go func() {
        fmt.Println(&quot;111&quot;)
        done &lt;- 1       // 同步语句 1
    }()
    &lt;- done              // 同步语句2
     fmt.Println(&quot;222&quot;)
}
</code></pre>
<p>done &lt;- 1：向channel传值；&lt;- done：从channel取值。<br>
<u>向channel传值取值先写谁都无所谓，因为传了没人取，和想取没人传，都会使channel阻塞</u>，<br>
因此同步语句2能够顺利执行(不阻塞)，就意味着同步语句1肯定执行了，又因为在一个goroutine中总能保证顺序一致性内存，因此在语句1执行之前，&quot;111&quot;肯定打印了，因此总能保证先打印&quot;111&quot;，再打印&quot;222&quot;。</p>
<h2 id="使用互斥量实现同步">使用互斥量实现同步</h2>
<pre><code class="language-Go">func main() {
    var mu sync.Mutex
    mu.Lock()
    go func() {
        fmt.Println(&quot;hello world&quot;)
        mu.Unlock()
    }()

    mu.Lock()
}
</code></pre>
<p>一个goroutine内的语句能够保证顺序一致性内存，所以打印语句必发生在Unlock()之前；在main线程中，先执行了第一个Lock()，那么通过sync.Mutex内部的保证，第二个Lock()必发生在goroutine中的Unlock()之后。因此能够保证该程序正常输出hello world。</p>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言并发编程模型(二) -- 原子操作]]></title>
        <id>https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-er-yuan-zi-cao-zuo/</id>
        <link href="https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-er-yuan-zi-cao-zuo/">
        </link>
        <updated>2020-11-29T15:46:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用互斥锁实现原子操作">使用互斥锁实现原子操作</h2>
<p>通常，原子操作由“互斥”访问保证，通常由特殊的CPU指令保护。当然，如果只是想模拟粗粒度的原子操作，我们可以使用<strong>sync.Mutex</strong>来做到这一点。</p>
<pre><code class="language-Go">package main

import (
    &quot;sync&quot;
    &quot;fmt&quot;
)

var total struct {
    sync.Mutex
    value int
}

func worker(wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i &lt; 100; i++ {
        total.Lock()
        total.value += 1
        total.Unlock()
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(2)
    go worker(&amp;wg)
    go worker(&amp;wg)
    wg.Wait()

    fmt.Println(total.value)    // 10100
}
</code></pre>
<h2 id="使用syncatomic实现原子操作">使用sync/atomic实现原子操作</h2>
<p>如上，使用互斥锁去保护数字共享资源既麻烦又低效。标准库中的<strong>sync/atomic</strong>包对此提供了丰富的支持。利用此包重新实现上面的例子：</p>
<pre><code class="language-Go">package main

import (
    &quot;sync&quot;
    &quot;sync/atomic&quot;
    &quot;fmt&quot;
)

var total uint64

func worker(wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i &lt;= 100; i++ {
        atomic.AddUnit64(&amp;total, i)
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(2)
    go worker(&amp;wg)
    go worker(&amp;wg)
    wg.Wait()

    fmt.Println(total.value)    // 10100
}
</code></pre>
<h2 id="利用原子操作和互斥锁实现单例">利用原子操作和互斥锁实现单例</h2>
<p>原子操作和互斥锁可以实现非常高效的单例模式。互斥锁的开销比普通整数的原子读写要高得多。 在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态降低互斥锁的使用次数来提高性能。</p>
<pre><code class="language-Go">type singleton struct {}

var (
    instance    *singleton
    initialized   uint32
    mu              sync.Mutex
)

func GetInst() *singleton {
    if atomic.LoadUint32(&amp;initialized) == 1 {
        return instance
    }

    mu.Lock()
    defer mu.Unlock()

    if instance == nil {
        defer atomic.StoreUint32(&amp;initialized, 1)
        instance = &amp;singleton {}
    }

    return instance
}
</code></pre>
<p>将上例中的公共部分提取出来就是标准库中的 <strong>sync.Once</strong>包。<strong>sync.Once</strong>源码如下所示：</p>
<pre><code class="language-Go">type Once struct {
    m      mutex
    done uint32
}

func (o *Once) Do(f func()) {
    if atomic.LoadUint32(&amp;o.Done) == 1 {
        return
    }
    o.m.Lock()
    defer o.m.Unlock()

    if o.done == 0 {
        defer atomic.StoreUint32(&amp;o.done, 1)
        f()
    }
}
</code></pre>
<p>现在，基于<strong>sync.Once</strong>重新实现单例模式：</p>
<pre><code class="language-Go">var (
    instance    *singleton
    once          sync.Once
)

func GetInst() *singleton {
    once.Do(func() {
        instance = &amp;singleton{}
    })
    return instance
}
</code></pre>
<h2 id="load-store">Load &amp; Store</h2>
<p><strong>atomic.Value</strong>对象提供了<strong>Load</strong>和<strong>Store</strong>两种方法，用于加载和保存数据。其返回值和参数均为**interface{}**类型，所以这两种方法可以用于自定义的任何复杂结构。</p>
<pre><code class="language-Go">/* This is a simplified producer-consumer model: back-end thread generate the latest configuration; multiple worker threads in the front-end get the latest configuration. All threads share configuration resources. */

// save the current configuration
var conf atomic.Value

// initialize the configuration
conf.Store(loadConfig())

// start a backend thread, load the updated configuration
go func() {
    for {
        time.Sleep(time.Second)
        conf.Store(loadConfig())
    }
}

// the worker threads used to process requests, always use the latest configuration
for i := 0; i &lt; 10; i++ {
    go func() {
        for r := range requests() {
            c := conf.Load()
        }
    }()
}
</code></pre>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言并发编程模型(一) -- 开篇]]></title>
        <id>https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-yi-kai-pian/</id>
        <link href="https://TomorrowTown.github.io/post/go-yu-yan-bing-fa-bian-cheng-mo-xing-yi-kai-pian/">
        </link>
        <updated>2020-11-29T15:17:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0x00">0x00</h2>
<p>首先看一下并发与并行的区别：<br>
并发：注意力更多地集中于设计层面，并发程序能够被顺序执行；<br>
并行：注意力更多地集中于运行层面，并发程序一般是大量简单重复的运算。<br>
在早期，CPU在一个单核中顺序地执行机器指令，所以早期地编程语言是一种顺序地编程语言：所有地指令都以串行地方式执行。当单核CPU的频率达到极限时，就会出现多核处理器，相应的，编程语言也需要朝着并行的方向发展。<br>
在并发编程中，对资源的精确访问需要精确的控制。在大多数语言中，这个困难的问题是通过锁和其他同步解决方案来解决的。但在golang中有另一种方式，它将共享的值通过channel传递。在任何时刻，最好只有一个goroutine可以拥有该资源。数据竞争在设计层面被消除。<br>
常用的并发编程模型有多线程模型、消息传递模型等。golang是基于消息并发实现其并发特性的，其将CSP并发编程模型内置到了语言中。与Erlang不同的是，golang的goroutine是由<strong>go</strong>这个关键字创建的共享内存。<br>
Golang并发编程的slogan：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<h2 id="go协程与系统线程">go协程与系统线程</h2>
<p>go协程(goroutine)是一种轻量级的线程。启动一个go协程，不仅简单如调用一个函数，而且启动的开销非常小，协程之间的调度成本也非常低。</p>
<h3 id="go协程与系统线程的差别">go协程与系统线程的差别</h3>
<p>go协程与系统线程的差别只是一个变量，但正是这个变量的区别导致了go并发编程的质的飞跃。<br>
**系统级线程：**具有固定的栈大小(通常默认是2MB)，该栈主要用于在递归调用函数时保存参数和局部变量。固定栈大小会导致两个问题：一是对许多只需要少量栈空间的线程来说是一种巨大的浪费；二是需要大量栈空间的线程会面临栈溢出的风险。<br>
**go协程：**goroutine以一个非常小的栈启动，栈大小不固定，可动态伸缩(最多为1GB)。因此启动成本非常小，所以可以启动成千上万个goroutine。</p>
<h3 id="goroutine的调度器">goroutine的调度器</h3>
<p>goroutine采用半抢占式的协作调度，只有在当前goroutine被阻塞时才会导致调度。同时，它发生在用户模式下。调度器会根据具体函数只保存必要的寄存器，切换成本远低于系统线程。运行时有一个<strong>runtime.GOMAXPROCS</strong>变量，用于控制当前运行正常非阻塞Goroutine的系统线程数。<br>
关于goroutine的调度器的详细说明请参阅：&lt;(https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/&gt;</p>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础(二) -- string]]></title>
        <id>https://TomorrowTown.github.io/post/go-yu-yan-ji-chu-er-zi-fu-chuan/</id>
        <link href="https://TomorrowTown.github.io/post/go-yu-yan-ji-chu-er-zi-fu-chuan/">
        </link>
        <updated>2020-11-29T13:48:29.000Z</updated>
        <content type="html"><![CDATA[<p>与数组不同，字符串中的元素是不可修改的，字符串是一个<strong>只读</strong>字节数组。<u>虽然字符串的长度一旦固定就不可修改，但长度并不是字符串类型的一部分</u>。<br>
由于Go的源码需要UTF8编码，所以出现在Go源码中的字符串常量通常是UTF8编码的。<br>
golang中的字符串底层数据结构为<strong>reflect.StringHeader：</strong></p>
<pre><code class="language-Go">type StringHeader struct {
    Data uintptr
    Len  int
}
</code></pre>
<p>The string structure consisits of two pieces of information: the first is the underlying byte array pointed by the string, and the second is the length of the string in bytes. The string is actually a structure, so the assignment of the string is the copy process of the <strong>reflect.StringHeader</strong> structure, and does not involve the copy of the underlying byte array.<br>
字符串结构包含两段信息：第一段是字符串所指向的底层字节数组；第二段是字符串的字节长度。字符串实际上是一个结构，所以字符串的赋值是 <strong>reflect.StringHeader</strong>结构的拷贝过程，修改赋值后的字符串并不会改变源字符串。<br>
<em>字符串&quot;Hello, World&quot; 对应的内存结构如图：</em><br>
<img src="https://TomorrowTown.github.io/post-images/1606658790160.png" alt="" loading="lazy"></p>
<p>虽然字符串不是切片，但是也支持针对切片的操作：</p>
<pre><code class="language-Go">s := &quot;hello, world&quot;
hello := s[:5]
world := s[7:]
</code></pre>
<p>字符串可以转换成<strong>byte[]</strong> 和 <strong>rune[]</strong>，且可使用<strong>for range</strong> 去遍历字符串。</p>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[游戏开发中的设计模式(一) -- 命令模式]]></title>
        <id>https://TomorrowTown.github.io/post/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi/</id>
        <link href="https://TomorrowTown.github.io/post/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi/">
        </link>
        <updated>2020-11-16T15:02:55.000Z</updated>
        <content type="html"><![CDATA[<p>A command is a reified method call.</p>
<h2 id="使用场景示例"><strong>使用场景示例</strong></h2>
<h3 id="输入处理"><strong>输入处理</strong></h3>
<p>每个游戏都有一处代码块用来处理用户原始的输入，如：按钮点击、键盘事件、鼠标点击等。<br>
它会记录输入并转换为游戏中的一个动作。<br>
简单实现：</p>
<pre><code class="language-cpp">void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) jump();
    else if (isPressed(BUTTON_Y)) fire();
    else if (isPressed(BUTTON_A)) swapWeapon();
    else if (isPressed(BUTTON_B)) lurchInffectively();
}
</code></pre>
<p>上述代码是有效的，但是如今许多游戏允许用户自定义按钮与游戏行为之间的映射关系。<br>
所以，为了支持自定义，我们需要把对jump()、fire()等方法的直接调用转换为<strong>可更换的</strong>东西。<br>
因此我们需要使用对象来代表一个游戏动作。这就用到了命令模式。<br>
首先，定义一个基类，代表一个可触发的游戏命令：</p>
<pre><code class="language-cpp">class Command
{
public:
    virtual ~Command() {}
    virtual void execute() = 0;    
};
</code></pre>
<p>然后为每一个不同的游戏动作创建一个子类：</p>
<pre><code class="language-cpp">class JumpCmd : public Command
{
public:
    virtual void execute() { jump(); }
};

class FireCmd : public Command
{
    virtual void execute() { fire(); }
};

/// #TODO: add more action subclass . . .
</code></pre>
<p>在输入处理中，为每个按钮存储一个指向命令的指针：</p>
<pre><code class="language-cpp">class InputHandler
{
public:
    void handleInput();

    ///  #TODO: method to bind commands . . .

private:
    Command* button_X;
    Command* button_Y;
    Command* button_A;
    Command* button_B;
};
</code></pre>
<p>现在对输入的处理便通过这些指针进行<strong>代理</strong>：</p>
<pre><code class="language-cpp">void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) button_X-&gt;execute();
    else if (isPressed(BUTTON_Y) button_Y-&gt;execute();
    else if (isPressed(BUTTON_A) button_A-&gt;execute();
    else if (isPressed(BUTTON_B) button_B-&gt;execute();
}
</code></pre>
<p>之前每个输入都会直接调用一个函数，现在则增加了一个间接调用层。</p>
<h4 id="解耦角色和命令"><strong>解耦角色和命令</strong></h4>
<p>在上例中，这些命令的使用范围很窄，只能作用于玩家对象。现在，让我们放宽限制，传入任何一个我们想要控制的对象，而不是让命令自身来确定所控制的对象：</p>
<pre><code class="language-cpp">class Command
{
public:
    virtual ~Command() {}
    virtual void execute(GameActor&amp; actor) = 0;
};

class JumpCmd : public Command
{
public:
    virtual void execute(GameActor&amp; actor) { actor.jump(); }
};
</code></pre>
<p>接下来修改输入处理方法，使其返回一个命令实例，以便调用具体的execute()：</p>
<pre><code class="language-cpp">Command* InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) return button_X;
    if (isPressed(BUTTON_Y)) return button_Y;
    if (isPressed(BUTTON_A)) return button_A;
    if (isPressed(BUTTON_B)) return button_B;

    return NULL;
}
</code></pre>
<p>最终，对输入的处理转化为动作的映射代码如下：</p>
<pre><code class="language-cpp">Command* cmd = inputHandler.handleInput();
if (cmd) { cmd-&gt;execute(actor); }
</code></pre>
<h3 id="undoredo"><strong>undo&amp;redo</strong></h3>
<p>命令模式一个重要的应用就是“撤销操作”。因为命令对象可以<strong>do</strong>一些事，那么就应该能够轻松地<strong>undo</strong>它们。这在游戏中应用广泛，比如策略游戏中的回滚操作，以及一些游戏的重播功能。<br>
上述例子中，我们希望从被操控的角色中抽象出命令，以便角色和命令解耦；但在这个例子中，我们希望<u>将命令绑定到被移动的角色</u>上，以便能够实现角色动作的回滚。<br>
示例代码：<br>
封装移动操作：</p>
<pre><code class="language-cpp">class MoveUnitCmd : public Command
{
public:
    MoveUnitCmd(Unit* unit, int x, int y) : mUnit(uint), mX(x), mY(y) {}
    virtual void execute() { mUnit-&gt;moveTo(mX, mY); }

private:
    Unit* mUnit;
    int mX;
    int mY;
};
</code></pre>
<p>之前的输入处理程序仅维护单一的命令对象，并在对应按钮被按下时调用其execute()方法。但这里，命令将更加具体，这意味着每次玩家选择一个动作，输入处理程序代码都会创建一个命令实例：</p>
<pre><code class="language-cpp">Command* handleInput()
{
    Unit* unit = getSelectedUnit();

    if (isPressed(BUTTON_UP)) {
        int destY = unit-&gt;y() - 1;
        return new MoveUnitCmd(unit, unit-&gt;x(), destY);
    }

    if (isPressed(BUTTON_DOWN)) {
        int destY = unit-&gt;y() + 1;
        return new MoveUnitCmd(unit, unit-&gt;x(), destY);
    }

    /// #TODO: others moves . . .

    return NULL;
}
</code></pre>
<p>Command类新增undo方法：</p>
<pre><code class="language-cpp">class Command
{
public:
    virtual ~Command() {}
    virtual void execute() = 0;
    virtual void undo() = 0;
}
</code></pre>
<p>进一步，修改上述子类，实现undo方法：</p>
<pre><code class="language-cpp">class MoveUnitCmd : public Command
{
public:
    MoveUnitCmd(Unit* unit, int x, int y)
    : mUnit(unit), mX(x), mY(y),
      xBefore(0), yBefore(0),
    {}

    virtual void execute()
    {
        // remember the unit's position before the move
        xBefore = mUnit-&gt;x();
        yBefore = mUnit-&gt;y();
        mUnit-&gt;moveTo(mX, mY);
    }

    virtual undo()
    {
        mUnit-&gt;moveTo(xBefore, yBefore);
    }

private:
    Unit* mUnit;
    int mX, mY;
    int xBefore, yBefore;
}
</code></pre>
<p>更进一步，可以支持多次撤销。<br>
具体思路是：不再只保存最后一个命令，而是维护一个命令列表和一个对当前命令的一个引用。当玩家执行了一个命令，就把该命令添加到这个列表，并将当前指针指向它。<br>
当玩家选择undo时，我们撤销当前的命令并将当前指针移回去；当选择redo时，将当前指针移回去，然后从此处开始执行列表中的命令。如果撤销之后选择了一个新命令，则列表中位于当前命令之后的所有命令都被舍弃掉。</p>
<blockquote>
<p>References:<br>
<a href="http://gameprogrammingpatterns.com/contents.html">Game Programming Patterns</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础(一) -- array]]></title>
        <id>https://TomorrowTown.github.io/post/golang-basics-array/</id>
        <link href="https://TomorrowTown.github.io/post/golang-basics-array/">
        </link>
        <updated>2020-11-12T13:50:51.000Z</updated>
        <content type="html"><![CDATA[<p>数组是一种固定长度的序列，可包含0个或多个元素。值得注意的是，<u>长度也是决定数组类型的因素。数组由不同长度或不同类型的数据组成，那么这些数组就是不同的类型，是不能直接赋值的</u>。因此在实际的golang项目中很少使用数组。对应于数组的类型是slice，slice是一种可以动态增长和收缩的序列，本章暂且不表。</p>
<pre><code class="language-Go">var a [3]int                        // define an int-type array of length 3, all the elements are 0
var b = [...]int{1, 2, 3}           // define an int-type array of length 3, elements are 1, 2, 3
var c = [...]int{2: 3, 1: 2}        // define an int-type of length 3, elements are 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6}     // define an int-type of length 3, elements are 1, 2, 0, 0, 5, 6, 

/*
值得注意的是第三种和第四种方法去定义一个数组。
第三种方法：golang支持数组中的元素通过索引去初始化，因此初始化时不必按照索引从0开始递增的方式去初始化。数组的长度基于初始化时出现的最大索引，未显式初始化的元素仍然使用0值初始化。
第四种方法：混合了第四种和第三种初始化方法。
*/
</code></pre>
<p><em>内存结构：</em><br>
<img src="https://TomorrowTown.github.io/post-images/1605189729922.png" alt="" loading="lazy"></p>
<p>golang中的数组是<a href="https://www.jianshu.com/p/8ca5ef5867cc">值语义</a>的。<u>一个数组变量代表的是整个数组，不像C++，代表的是数组第一个元素的指针</u>。当一个数组被赋值或是被传递，整个数组其实是被拷贝的，修改拷贝的数组并不会改变原数组的数据，因为他们并不共享底层数据结构。<br>
如果数组很大，那么数组分配也会有很大的开销。为了避免复制数组的开销，可以传递一个指向数组的指针，但数组指针不是数组。</p>
<pre><code class="language-Go">var a = [...]int{1, 2, 3}
var b = &amp;a

fmt.Println(a[0], a[1])     // Prints the first two elements of the array
fmt.Println(b[0], b[1])     // Accessing array elements through array pointer is similar to arrays

// Iterate through the elements of an array through array pointer.
for i, v = range b {
    ......
}
</code></pre>
<h2 id="遍历数组的常用方法">遍历数组的常用方法</h2>
<pre><code class="language-Go">for i := range a {
}
for i, v := range a {
}
for i := 0 ; i &lt; len(a); i++ {
}
</code></pre>
<p>需要注意的是，使用<strong>for range</strong>的方式进行遍历，其性能要比传统的**for i := 0 ; i &lt; len(a); i++ **要差很多。具体原因请查看：<a href="https://www.flysnow.org/2018/10/20/golang-for-range-slice-map.html">https://www.flysnow.org/2018/10/20/golang-for-range-slice-map.html</a></p>
<h2 id="数组的其他用途">数组的其他用途</h2>
<p>数组不仅可以用于数字类型，还可以是字符串数组，结构体数组，函数数组，接口数组，管道数组等等：</p>
<pre><code class="language-Go">// string array
var s1 = [...]string{&quot;hello&quot;, &quot;world&quot;}

// structure array
var line = [...]image.point{{0, 0}, {1, 1}}

// function array
var decoder = [...]func(io.Reader) (image.Image, error) {
    png.Decode,
    jpeg.Decode,
}
// interface array
var unknown = [...]interface{}{123, &quot;hello&quot;}

// pipe array
var chanList = [2]chan int{}
</code></pre>
<p>也可以定义空数组：</p>
<pre><code class="language-Go">var d = [0]int
var e = [0]int{}
var f = [...]int{}
</code></pre>
<p>长度为0的数组不占用内存空间。虽然空数组很少被使用，但它们可以用来强调某些类型的操作，以避免分配额外的内存空间，例如管道同步操作：</p>
<pre><code class="language-Go">c1 := make(chan [0]int)
go func() {
    fmt.Println(&quot;c1&quot;)
    c1 &lt;- [0]int{}
}()
&lt;- c1
</code></pre>
<p>此处我们不关心管道中传输的实际数据类型，管道中的接收和发送操作仅用于消息同步。对于这个应用场景，我们使用一个空数组作为管道类型，以减少分配管道元素的开销。<br>
当然，通常更倾向于使用无类型的匿名结构体以达到相同的目的：</p>
<pre><code class="language-Go">c2 := make(chan struct{})
go func() {
    fmt.Println(&quot;c2&quot;)
    c2 &lt;- struct{}{}    // The part of 'struc{}' means type, and the '{}' represents the value of the structure
}()
&lt;- c2
</code></pre>
<p>在golang中，数组是切片和字符串的基础结构。数组的许多操作都可直接用于切片和字符串。</p>
<blockquote>
<p>References:<br>
<a href="https://chai2010.cn/advanced-go-programming-book/">Advanced Go Programming</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go服务器性能分析方法]]></title>
        <id>https://TomorrowTown.github.io/post/go-fu-wu-qi-xing-neng-fen-xi-gong-ju/</id>
        <link href="https://TomorrowTown.github.io/post/go-fu-wu-qi-xing-neng-fen-xi-gong-ju/">
        </link>
        <updated>2020-11-05T14:32:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pprof">pprof</h2>
<ol>
<li>在需要监测的server源码中的main或init中引入:</li>
</ol>
<pre><code class="language-go">import _ &quot;net/http/pprof&quot;
</code></pre>
<ol start="2">
<li>启动http监听端口，以此作为性能分析数据展示网页。</li>
</ol>
<pre><code class="language-go">go http.ListenAndServe(&quot;:9999&quot;, nil)
</code></pre>
<p>这样，默认访问地址为localhost:9999。</p>
<blockquote>
<p>无论是否是http服务, 都可以引入<strong>net/http/pprof</strong>作为性能分析的工具。</p>
</blockquote>
<h2 id="go-torch和flamegraph">go-torch和FlameGraph</h2>
<ol>
<li>安装go-torch和FlameGraph</li>
</ol>
<pre><code class="language-shell">go get github.com/uber/go-torch
cd $GOPATH/src/github.com/uber/go-torch
git clone https://github.com/brendangregg/FlameGraph.git
sudo cp ./FlameGraph/flamegraph.pl /usr/local/bin
</code></pre>
<p>**NOTE: **go get到的项目默认会放到用户目录下的go文件夹，以此作为该项目的GOPATH。</p>
<blockquote>
<p>可能遇到的问题:<br>
go get github.com/uber/go-torch时，有可能出现：</p>
<pre><code class="language-shell">unrecognized import path &quot;golang.org/x/sys/unix&quot;: https fetch: Get . . . . . . i/o timeout
</code></pre>
<p>此时需要:</p>
<pre><code class="language-shell">mkdir -p $GOPATH/src/golang.org.x
cd $GOPATH/src/golang.org/x
git clone https://github.com/golang/sys.git 即可
</code></pre>
</blockquote>
<ol start="2">
<li>安装包管理工具<br>
glide用于编译上述下载的go-torch。</li>
</ol>
<pre><code class="language-shell">go get github.com/Masterminds/glide
cd $GOPATH/src/github.com/uber/go-torch
glide install
</code></pre>
<blockquote>
<p>可能遇到的问题:<br>
在glide install时可能出现:<br>
<img src="https://TomorrowTown.github.io/post-images/1604588907765.png" alt="" loading="lazy"><br>
直接无视即可。</p>
</blockquote>
<ol start="3">
<li>运行测试用例</li>
</ol>
<pre><code class="language-shell">...... go-torch]$ go test ./...
</code></pre>
<blockquote>
<p>可能遇到的问题:<br>
出现一堆编译报错。但只要下列语句都没fail, 即可无视其他报错：<br>
<img src="https://TomorrowTown.github.io/post-images/1604588991700.png" alt="" loading="lazy"><br>
最后需要到GOPATH的bin目录下查看是否生成了<strong>go-torch</strong>可执行文件, 有则成功</p>
</blockquote>
<h2 id="运行go-torch获取火焰图">运行go-torch获取火焰图</h2>
<p>在成功完成了上述所有步骤后，在任意文件夹下都可运行 go-torch命令了。<br>
例：</p>
<pre><code class="language-shell">go-torch -u http://localhost:9999 -t 30 -f perf.svg
</code></pre>
<p>等待30s，在运行命令的目录下就会生成一份perf.svg（默认是torch.svg）文件, 直接网页打开(实测chome/Edge可正常打开并可点击方块zoom in)该文件即可看到火焰图：<br>
<img src="https://TomorrowTown.github.io/post-images/1604589121478.png" alt="" loading="lazy"></p>
<h2 id="进一步寻找性能痛点">进一步寻找性能痛点</h2>
<p>再次用相同的测试条件测试，不过现在仅需要运行：</p>
<pre><code class="language-shell">go tool pprof --seconds 60 http://localhost:9999/debug/pprof/profile
</code></pre>
<p>60s后会得到cpu分析文件，此时不再是火焰图。<br>
根据之前获得的火焰图，找到不应该占用那么多CPU但是却占用了那么多的方法。<br>
在命令行窗口(pprof)后输入<strong>list 方法名</strong>，<br>
如果找到了具体哪一步消耗的cpu高，如果该步是另一个包的方法，也无所谓，直接<strong>list 方法名</strong>即可。<br>
(ps: 输入exit可退出go tool pprof)<br>
会得到该方法中具体哪一步cpu消耗的值，进而得到了该方法的性能痛点。<br>
最后就着手优化吧:)</p>
<p><strong>Tips：<strong>火焰图中，纵轴从下到上代表</strong>调用顺序</strong>，横轴每个方块的长度代表<strong>占用CPU的时长百分比</strong>。</p>
]]></content>
    </entry>
</feed>