{"posts":[{"fileName":"2020-12-9-golang-basics-context","abstract":"","description":"0x00 在Go1.7发布时，标准库增加了一个context包，用来简化对于处理单个请求的多个goroutine之间与请求域的数据、超时和退出等操作。 context包的应用 1. 线程安全退出和超时控制 // when the concu...","title":"Go语言并发编程模型(九) -- context","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-9-golang-basics-context.png","link":"https://TomorrowTown.github.io/post/2020-12-9-golang-basics-context/","stats":{"text":"2 min read","time":93000,"words":307,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#0x00\">0x00</a></li>\n<li><a href=\"#context%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8\">context包的应用</a>\n<ul>\n<li><a href=\"#1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E5%92%8C%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6\">1. 线程安全退出和超时控制</a></li>\n<li><a href=\"#2-%E9%98%B2%E6%AD%A2%E5%90%8E%E5%8F%B0goroutine%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\">2. 防止后台goroutine内存泄漏</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-12-09 23:56:28","dateFormat":"2020-12-09"},{"fileName":"2020-12-09-golang-basics-concurrent-exit-safely","abstract":"","description":"0x00 当select有许多分支时，会随机选择一个可用的channel分支，若没有可用channel分支，则default分支将会被选择，否则会一直保持阻塞状态。 select语句的应用 1. 超时判断 // choose one of ...","title":"Go语言并发编程模型(八) -- 并发的安全退出","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-09-golang-basics-concurrent-exit-safely.png","link":"https://TomorrowTown.github.io/post/2020-12-09-golang-basics-concurrent-exit-safely/","stats":{"text":"3 min read","time":126000,"words":449,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#0x00\">0x00</a>\n<ul>\n<li><a href=\"#select%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%BA%94%E7%94%A8\">select语句的应用</a>\n<ul>\n<li><a href=\"#1-%E8%B6%85%E6%97%B6%E5%88%A4%E6%96%AD\">1. 超时判断</a></li>\n<li><a href=\"#2-%E9%9D%9E%E9%98%BB%E5%A1%9Echannel%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%93%8D%E4%BD%9C\">2. 非阻塞channel的发送和接收操作</a></li>\n<li><a href=\"#3-%E9%98%BB%E6%AD%A2main%E5%87%BD%E6%95%B0%E9%80%80%E5%87%BA\">3. 阻止main函数退出</a></li>\n<li><a href=\"#4%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BA%8F%E5%88%97\">4.生成随机数序列</a></li>\n<li><a href=\"#5%E5%8D%8F%E7%A8%8B%E9%80%80%E5%87%BA%E6%8E%A7%E5%88%B6\">5.协程退出控制</a>\n<ul>\n<li><a href=\"#1-%E5%85%B3%E9%97%AD%E4%B8%80%E4%B8%AAgoroutine\">(1) 关闭一个goroutine</a></li>\n<li><a href=\"#2-%E5%85%B3%E9%97%AD%E5%A4%9A%E4%B8%AAgoroutine\">(2) 关闭多个goroutine</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-12-09 23:55:41","dateFormat":"2020-12-09"},{"fileName":"2020-12-09-golang-basics-control-the-number-of-concurrent","abstract":"","description":"控制并发数的意义 适当地控制并发数，能够为其他程序提供可供使用的CPU资源，也可以节省能耗。 对于细粒度的并发程序而言，CSP模型中的消息传递机制的开销是非常大的(多线程并发模型不可避免地会面对线程启动的开销)。 使用有缓冲channel实...","title":"Go语言并发编程模型(七) -- 控制并发数","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-09-golang-basics-control-the-number-of-concurrent.png","link":"https://TomorrowTown.github.io/post/2020-12-09-golang-basics-control-the-number-of-concurrent/","stats":{"text":"1 min read","time":51000,"words":196,"minutes":1},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E7%9A%84%E6%84%8F%E4%B9%89\">控制并发数的意义</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E6%9C%89%E7%BC%93%E5%86%B2channel%E5%AE%9E%E7%8E%B0groutine%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8E%A7%E5%88%B6\">使用有缓冲channel实现groutine的并发数控制</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-12-09 23:52:58","dateFormat":"2020-12-09"},{"fileName":"2020-12-08-golang-basics-publish-and-subscribe-model","abstract":"","description":"0x00 相比于生产者消费者模型而言，消息的生产者在发布订阅模型中充当了消息的发布者(publisher)，消息的消费者充当了消息的订阅者(subscriber)。 在传统的生产者消费者模型中，消息被发送到一个队列中，而在发布订阅模型中，消...","title":"Go语言并发编程模型(六) -- 发布订阅模型","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-08-golang-basics-publish-and-subscribe-model.png","link":"https://TomorrowTown.github.io/post/2020-12-08-golang-basics-publish-and-subscribe-model/","stats":{"text":"3 min read","time":178000,"words":570,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#0x00\">0x00</a></li>\n<li><a href=\"#%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A4%9A%E4%B8%BB%E9%A2%98%E7%9A%84pub-sub%E5%BA%93%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0\">一个支持多主题的pub-sub库的简易实现</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-12-08 23:52:10","dateFormat":"2020-12-08"},{"fileName":"2020-12-07-golang-basics-producer-and-consumer-model","abstract":"","description":"talk is cheap, show you the code: // producer: generate a sequence of multiples of factor func Producer(factor int, out ...","title":"Go语言并发编程模型(五) -- 生产者消费者模型","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-07-golang-basics-producer-and-consumer-model.png","link":"https://TomorrowTown.github.io/post/2020-12-07-golang-basics-producer-and-consumer-model/","stats":{"text":"2 min read","time":72000,"words":193,"minutes":2},"isTop":false,"toc":"","date":"2020-12-07 23:51:39","dateFormat":"2020-12-07"},{"fileName":"2020-12-04-golang-basics-channel-based-communication","abstract":"","description":"0x00 依靠channel通信是不同goroutine之间同步的主要方法。 无缓冲channel 对于无缓冲channel而言，每一个发送操作(chan &lt;- x)都对应一个接收操作(&lt;- chan)，反之亦然。channel...","title":"Go语言并发编程模型(四) -- 基于管道的通信","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-04-golang-basics-channel-based-communication.png","link":"https://TomorrowTown.github.io/post/2020-12-04-golang-basics-channel-based-communication/","stats":{"text":"3 min read","time":122000,"words":473,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#0x00\">0x00</a></li>\n<li><a href=\"#%E6%97%A0%E7%BC%93%E5%86%B2channel\">无缓冲channel</a></li>\n<li><a href=\"#%E6%9C%89%E7%BC%93%E5%86%B2channel\">有缓冲channel</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-12-04 23:47:37","dateFormat":"2020-12-04"},{"fileName":"2020-12-03-golang-basics-sequential-consistency-memory-model","abstract":"","description":"0x00 原子操作能够为线程之间的数据同步提供部分保证的前提是顺序一致性内存模型。 线程间同步的本质就是为并发的事件进行排序。 以下为一个顺序一致性内存模型： var a string var done bool func set() {...","title":"Go语言并发编程模型(三) -- 顺序一致性内存模型","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-03-golang-basics-sequential-consistency-memory-model.png","link":"https://TomorrowTown.github.io/post/2020-12-03-golang-basics-sequential-consistency-memory-model/","stats":{"text":"3 min read","time":161000,"words":691,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#0x00\">0x00</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5\">使用同步原语进行同步</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5\">使用互斥量实现同步</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-12-03 23:47:13","dateFormat":"2020-12-03"},{"fileName":"2020-12-02-golang-basics-atomic-operation","abstract":"","description":"使用互斥锁实现原子操作 通常，原子操作由“互斥”访问保证，通常由特殊的CPU指令保护。当然，如果只是想模拟粗粒度的原子操作，我们可以使用sync.Mutex来做到这一点。 package main import ( &quot;s...","title":"Go语言并发编程模型(二) -- 原子操作","tags":[],"feature":"https://TomorrowTown.github.io/post-images/2020-12-02-golang-basics-atomic-operation.png","link":"https://TomorrowTown.github.io/post/2020-12-02-golang-basics-atomic-operation/","stats":{"text":"4 min read","time":187000,"words":647,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\">使用互斥锁实现原子操作</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8syncatomic%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\">使用sync/atomic实现原子操作</a></li>\n<li><a href=\"#%E5%88%A9%E7%94%A8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B\">利用原子操作和互斥锁实现单例</a></li>\n<li><a href=\"#load-store\">Load &amp; Store</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-12-02 23:46:13","dateFormat":"2020-12-02"},{"fileName":"2020-12-01-golang-basics-introductory-remarks","abstract":"","description":"0x00 首先看一下并发与并行的区别： 并发：注意力更多地集中于设计层面，并发程序能够被顺序执行； 并行：注意力更多地集中于运行层面，并发程序一般是大量简单重复的运算。 在早期，CPU在一个单核中顺序地执行机器指令，所以早期地编程语言是一种...","title":"Go语言并发编程模型(一) -- 开篇","tags":[{"index":-1,"name":"golang","slug":"lXXd7xbfA","used":true,"link":"https://TomorrowTown.github.io/tag/lXXd7xbfA/"}],"feature":"https://TomorrowTown.github.io/post-images/2020-12-01-golang-basics-introductory-remarks.png","link":"https://TomorrowTown.github.io/post/2020-12-01-golang-basics-introductory-remarks/","stats":{"text":"3 min read","time":162000,"words":760,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#0x00\">0x00</a></li>\n<li><a href=\"#go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B\">go协程与系统线程</a>\n<ul>\n<li><a href=\"#go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%AB\">go协程与系统线程的差别</a></li>\n<li><a href=\"#goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8\">goroutine的调度器</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-11-29 23:17:26","dateFormat":"2020-11-29"},{"fileName":"2020-11-29-golang-basics-string","abstract":"","description":"与数组不同，字符串中的元素是不可修改的，字符串是一个只读字节数组。虽然字符串的长度一旦固定就不可修改，但长度并不是字符串类型的一部分。 由于Go的源码需要UTF8编码，所以出现在Go源码中的字符串常量通常是UTF8编码的。 golang中的...","title":"Go语言基础(二) -- string","tags":[{"index":-1,"name":"golang","slug":"lXXd7xbfA","used":true,"link":"https://TomorrowTown.github.io/tag/lXXd7xbfA/"}],"feature":"https://TomorrowTown.github.io/post-images/2020-11-29-golang-basics-string.png","link":"https://TomorrowTown.github.io/post/2020-11-29-golang-basics-string/","stats":{"text":"2 min read","time":85000,"words":339,"minutes":2},"isTop":false,"toc":"","date":"2020-11-29 21:48:29","dateFormat":"2020-11-29"},{"fileName":"you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi","abstract":"","description":"A command is a reified method call. 使用场景示例 输入处理 每个游戏都有一处代码块用来处理用户原始的输入，如：按钮点击、键盘事件、鼠标点击等。 它会记录输入并转换为游戏中的一个动作。 简单实现： void...","title":"游戏开发中的设计模式(一) -- 命令模式","tags":[{"name":"游戏开发","slug":"CHJWtbNKg","used":true,"link":"https://TomorrowTown.github.io/tag/CHJWtbNKg/"},{"name":"设计模式","slug":"4AAgEC-1o","used":true,"link":"https://TomorrowTown.github.io/tag/4AAgEC-1o/"}],"feature":"https://TomorrowTown.github.io/post-images/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi.jpeg","link":"https://TomorrowTown.github.io/post/you-xi-kai-fa-zhong-de-she-ji-mo-shi-yi-ming-ling-mo-shi/","stats":{"text":"5 min read","time":288000,"words":1145,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B\"><strong>使用场景示例</strong></a>\n<ul>\n<li><a href=\"#%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86\"><strong>输入处理</strong></a>\n<ul>\n<li><a href=\"#%E8%A7%A3%E8%80%A6%E8%A7%92%E8%89%B2%E5%92%8C%E5%91%BD%E4%BB%A4\"><strong>解耦角色和命令</strong></a></li>\n</ul>\n</li>\n<li><a href=\"#undoredo\"><strong>undo&amp;redo</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-11-16 23:02:55","dateFormat":"2020-11-16"},{"fileName":"2020-11-12-golang-basics-array","abstract":"","description":"数组是一种固定长度的序列，可包含0个或多个元素。值得注意的是，长度也是决定数组类型的因素。数组由不同长度或不同类型的数据组成，那么这些数组就是不同的类型，是不能直接赋值的。因此在实际的golang项目中很少使用数组。对应于数组的类型是sli...","title":"Go语言基础(一) -- array","tags":[{"index":-1,"name":"golang","slug":"lXXd7xbfA","used":true,"link":"https://TomorrowTown.github.io/tag/lXXd7xbfA/"}],"feature":"https://TomorrowTown.github.io/post-images/2020-11-12-golang-basics-array.png","link":"https://TomorrowTown.github.io/post/2020-11-12-golang-basics-array/","stats":{"text":"5 min read","time":249000,"words":986,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\">遍历数组的常用方法</a></li>\n<li><a href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E9%80%94\">数组的其他用途</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-11-12 21:50:51","dateFormat":"2020-11-12"},{"fileName":"2020-11-05-go-server-performance-analyze","abstract":"","description":"pprof 在需要监测的server源码中的main或init中引入: import _ &quot;net/http/pprof&quot; 启动http监听端口，以此作为性能分析数据展示网页。 go http.ListenAn...","title":"go服务器性能分析方法","tags":[{"name":"服务器开发","slug":"n9MXmjtY-","used":true,"link":"https://TomorrowTown.github.io/tag/n9MXmjtY-/"},{"index":-1,"name":"golang","slug":"lXXd7xbfA","used":true,"link":"https://TomorrowTown.github.io/tag/lXXd7xbfA/"}],"feature":"https://TomorrowTown.github.io/post-images/2020-11-05-go-server-performance-analyze.jpeg","link":"https://TomorrowTown.github.io/post/2020-11-05-go-server-performance-analyze/","stats":{"text":"3 min read","time":167000,"words":681,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#pprof\">pprof</a></li>\n<li><a href=\"#go-torch%E5%92%8Cflamegraph\">go-torch和FlameGraph</a></li>\n<li><a href=\"#%E8%BF%90%E8%A1%8Cgo-torch%E8%8E%B7%E5%8F%96%E7%81%AB%E7%84%B0%E5%9B%BE\">运行go-torch获取火焰图</a></li>\n<li><a href=\"#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AF%BB%E6%89%BE%E6%80%A7%E8%83%BD%E7%97%9B%E7%82%B9\">进一步寻找性能痛点</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-11-05 22:32:00","dateFormat":"2020-11-05"}],"tags":[{"index":-1,"name":"golang","slug":"lXXd7xbfA","used":true,"link":"https://TomorrowTown.github.io/tag/lXXd7xbfA/","count":4},{"name":"游戏开发","slug":"CHJWtbNKg","used":true,"link":"https://TomorrowTown.github.io/tag/CHJWtbNKg/","count":1},{"name":"设计模式","slug":"4AAgEC-1o","used":true,"link":"https://TomorrowTown.github.io/tag/4AAgEC-1o/","count":1},{"name":"服务器开发","slug":"n9MXmjtY-","used":true,"link":"https://TomorrowTown.github.io/tag/n9MXmjtY-/","count":1}],"menus":[{"link":"https://TomorrowTown.github.io","name":"首页","openType":"Internal"},{"link":"https://TomorrowTown.github.io/tags","name":"标签","openType":"Internal"},{"link":"https://TomorrowTown.github.io/archives","name":"文档","openType":"Internal"},{"link":"https://TomorrowTown.github.io/post/about","name":"关于","openType":"Internal"}],"themeConfig":{"themeName":"Card","postPageSize":10,"archivesPageSize":50,"siteName":"tomorrow","siteDescription":"\"我猪肉佬何尝不想当一个伟大的舞蹈家\"","footerInfo":"","showFeatureImage":true,"domain":"https://TomorrowTown.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{"Valine":"on","avatar_":"","baidu":"on","bg":"#fefefe","bilibili":"","build_time":"2020-11-5","card_bg":"https://s3.ax1x.com/2020/12/02/DoJZM6.png","copyright":"on","donate":"off","donate_alipay":"https://blog.itjoker.cn/alipay.jpg","donate_wechat":"https://blog.itjoker.cn/wechat.jpg","facebook":"","friends":[],"ga":"","github":"https://github.com/TomorrowTown","icpcode":"","icpinfo":"沪公网备案 没有号~","instagram":"","keywords":"","linkedin":"","music":"off","music_model":"normal","musics":[],"platformLink":"https://coding.net","platformName":"Coding","qq":"","send":"","sentence":"off","sidebars":[{"siteLcontentink":"","title":""}],"tumblr":"","twitter":"","valineAppId":"","valineAppKey":"","valineAvatar":"mp","valineHighlight":true,"valinePageSize":10,"valinePlaceholder":"来都来了，不妨评论一下","valineRecordIp":false,"valineVisitor":true,"view":"on","weather":"on","wechat":"","weibo":"","youtube":"","zhihu":"https://www.zhihu.com/people/tang-ming-tian-68"},"utils":{"now":1607446893267}}